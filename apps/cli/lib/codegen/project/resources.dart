import 'package:aws_common/aws_common.dart';
import 'package:celest_cli/ast/ast.dart' hide Parameter;
import 'package:celest_cli/codegen/types.dart';
import 'package:celest_cli/src/utils/reference.dart';
import 'package:code_builder/code_builder.dart';

const _header = [
  'Generated by `celest start`. This file should not be modified manually, but',
  'it can be checked into version control.',
];

final class ResourcesGenerator {
  ResourcesGenerator({
    required this.project,
  });

  final Project project;
  final _library = LibraryBuilder()
    ..name = ''
    ..comments.addAll(_header);

  final _referencesByEnvironment = <String, Set<String>>{};
  void _saveReference(String environmentName, String ref) {
    (_referencesByEnvironment[environmentName] ??= {}).add(ref);
  }

  final _classBuilders = <String, ClassBuilder>{};
  ClassBuilder _beginClass(String name) {
    final cached = _classBuilders[name];
    if (cached != null) {
      return cached;
    }
    final builder = ClassBuilder()
      ..name = name
      ..abstract = true
      ..modifier = ClassModifier.final$;
    _library.body.add(lazySpec(builder.build));
    return builder;
  }

  void _generateApi(
    String apiName,
    Map<String, Api> environments, {
    required ClassBuilder apisClass,
    required ClassBuilder functionsClass,
  }) {
    for (final MapEntry(key: environmentName, value: api)
        in environments.entries) {
      final apiClass = switch (environmentName) {
        '' => apisClass,
        _ => _beginClass('${environmentName.camelCase}Apis'),
      };
      final functionClass = switch (environmentName) {
        '' => functionsClass,
        _ => _beginClass('${environmentName.camelCase}Functions'),
      };
      apiClass.fields.add(
        Field(
          (f) => f
            ..static = true
            ..modifier = FieldModifier.constant
            ..name = api.name.camelCase
            ..assignment = DartTypes.celest.cloudApi.constInstance([], {
              'name': literalString(api.name, raw: true),
              if (environmentName != '')
                'environmentName': literalString(environmentName, raw: true),
            }).code,
        ),
      );
      for (final function in api.functions.values) {
        final inputParameters = function.parameters
            .where((p) => !p.type.isFunctionContext)
            .toList();
        final inputType = switch (inputParameters) {
          [] => refer('void'),
          [final single] => single.type,
          final multiple => RecordType(
              (r) => r
                // TODO(dnys1): Treat all parameters the same (named/optional)?
                // This is only a Dart concept and we can handle the mapping to/from.
                // i.e. it does not affect the actual HTTP API.
                ..positionalFieldTypes.addAll([
                  for (final parameter in multiple.where((p) => !p.named))
                    parameter.type,
                ])
                ..namedFieldTypes.addAll({
                  for (final parameter in multiple.where((p) => p.named))
                    parameter.name: parameter.type,
                }),
            ),
        };
        final functionName = '${apiName}_${function.name}'.camelCase;
        functionClass.fields.add(
          Field(
            (f) => f
              ..static = true
              ..name = functionName
              ..modifier = FieldModifier.constant
              ..assignment = DartTypes.celest
                  .cloudFunction(
                inputType,
                function.flattenedReturnType,
              )
                  .constInstance([], {
                'api': literalString(api.name, raw: true),
                'functionName': literalString(function.name, raw: true),
                if (environmentName.isNotEmpty)
                  'environmentName': literalString(environmentName, raw: true),
              }).code,
          ),
        );
        if (environmentName.isEmpty) {
          final overriddenEnvironments =
              environments.keys.where((env) => env.isNotEmpty).toSet();
          final baseEnvironments = {
            ...project.environmentNames,
          }.difference(overriddenEnvironments);
          final apiRef = 'apis.${apiName.camelCase}';
          final functionRef = 'functions.$functionName';
          if (overriddenEnvironments.isEmpty) {
            _saveReference('', apiRef);
            _saveReference('', functionRef);
          } else {
            for (final environment in baseEnvironments) {
              _saveReference(environment, apiRef);
              _saveReference(environment, functionRef);
            }
          }
        } else {
          _saveReference(
            environmentName,
            '${environmentName.camelCase}Apis.${apiName.camelCase}',
          );
          _saveReference(
            environmentName,
            '${environmentName.camelCase}Functions.$functionName',
          );
        }
      }
    }
  }

  Library generate() {
    final allApis = <String, Map<String, Api>>{};
    for (final environment in [
      project.baseEnvironment,
      ...project.environmentOverrides.values,
    ]) {
      for (final api in environment.apis.values) {
        (allApis[api.name] ??= {})[environment.name ?? ''] = api;
      }
    }
    if (allApis.isNotEmpty) {
      final apisClass = _beginClass('apis');
      final functionsClass = _beginClass('functions');
      for (final MapEntry(key: apiName, value: environments)
          in allApis.entries) {
        _generateApi(
          apiName,
          environments,
          apisClass: apisClass,
          functionsClass: functionsClass,
        );
      }
    }
    _library.body.add(
      Method(
        (m) => m
          ..returns = DartTypes.core.list(DartTypes.celest.cloudWidget)
          ..name = 'forEnvironment'
          ..requiredParameters.add(
            Parameter(
              (p) => p
                ..name = 'environment'
                ..type = DartTypes.core.string,
            ),
          )
          ..body = Block((b) {
            b.addExpression(
              declareConst('base').assign(
                literalConstList(
                  [
                    ...?_referencesByEnvironment['']?.map(refer),
                  ],
                  DartTypes.celest.cloudWidget,
                ),
              ),
            );
            for (final environmentName in project.environmentNames) {
              final overrides = _referencesByEnvironment[environmentName];
              b.statements.add(
                (overrides == null
                        ? refer('base')
                        : literalConstList(
                            [refer('base').spread, ...overrides.map(refer)],
                            DartTypes.celest.cloudWidget,
                          ))
                    .returned
                    .wrapWithBlockIf(
                      refer('environment')
                          .equalTo(literalString(environmentName)),
                    ),
              );
            }
            b.addExpression(
              DartTypes.core.stateError.call([
                literalString(r'Unknown environment: $environment'),
              ]).thrown,
            );
          }),
      ),
    );
    return _library.build();
  }
}
