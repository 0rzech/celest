import 'package:aws_common/aws_common.dart';
import 'package:celest_cli/ast/ast.dart';
import 'package:celest_cli/codegen/types.dart';
import 'package:celest_cli/src/utils/reference.dart';
import 'package:code_builder/code_builder.dart';

const _header = [
  'Generated by `celest start`. This file should not be modified manually, but',
  'it can be checked into version control.',
];

final class ResourcesGenerator {
  ResourcesGenerator({
    required this.project,
  });

  final Project project;
  final _library = LibraryBuilder()
    ..name = ''
    ..comments.addAll(_header);

  (Reference, ClassBuilder) _beginClass(String name) => (
        refer(name),
        ClassBuilder()
          ..name = name
          ..modifier = ClassModifier.final$
          ..constructors.add(Constructor((c) => c..constant = true)),
      );

  (Reference, Class) _generateApi(
    String apiName,
    Map<String, Api> environments,
  ) {
    final apiClassName = '\$_Celest${apiName.pascalCase}ApiResource';
    final (apiClassRef, apiClass) = _beginClass(apiClassName);
    for (final MapEntry(key: environmentName, value: api)
        in environments.entries) {
      final (environmentClassRef, environmentClass) = _beginClass(
        '\$_Celest${apiName.pascalCase}${environmentName.pascalCase}ApiResource',
      );
      if (environmentName.isNotEmpty) {
        apiClass.fields.add(
          Field(
            (b) => b
              ..name = '${environmentName.camelCase}\$'
              ..modifier = FieldModifier.final$
              ..type = environmentClassRef
              ..assignment = environmentClassRef.constInstance([]).code,
          ),
        );
        _library.body.add(lazySpec(environmentClass.build));
      }
      for (final function in api.functions.values) {
        final inputParameters = function.parameters
            .where((p) => !p.type.isFunctionContext)
            .toList();
        final inputType = switch (inputParameters) {
          [] => refer('void'),
          [final single] => single.type,
          final multiple => RecordType(
              (r) => r
                // TODO(dnys1): Treat all parameters the same (named/optional)?
                // This is only a Dart concept and we can handle the mapping to/from.
                // i.e. it does not affect the actual HTTP API.
                ..positionalFieldTypes.addAll([
                  for (final parameter in multiple.where((p) => !p.named))
                    parameter.type,
                ])
                ..namedFieldTypes.addAll({
                  for (final parameter in multiple.where((p) => p.named))
                    parameter.name: parameter.type,
                }),
            ),
        };
        final functionField = Field(
          (f) => f
            ..name = function.name.camelCase
            ..modifier = FieldModifier.final$
            ..assignment = DartTypes.celest
                .cloudFunction(
              inputType,
              function.flattenedReturnType,
            )
                .constInstance([], {
              'api': literalString(api.name, raw: true),
              'functionName': literalString(function.name, raw: true),
              if (environmentName.isNotEmpty)
                'environmentName': literalString(environmentName, raw: true),
            }).code,
        );
        if (environmentName.isEmpty) {
          apiClass.fields.add(functionField);
        } else {
          environmentClass.fields.add(functionField);
        }
      }
    }
    return (apiClassRef, apiClass.build());
  }

  Library generate() {
    final (celestClassRef, celestClass) = _beginClass(r'$_CelestResources');
    _library.body.addAll([
      Field(
        (b) => b
          ..name = 'resources'
          ..modifier = FieldModifier.constant
          ..type = celestClassRef
          ..assignment = celestClassRef.constInstance([]).code,
      ),
      lazySpec(celestClass.build),
    ]);
    final allApis = <String, Map<String, Api>>{};
    for (final environment in [
      project.baseEnvironment,
      ...project.environmentOverrides.values,
    ]) {
      for (final api in environment.apis.values) {
        (allApis[api.name] ??= {})[environment.name ?? ''] = api;
      }
    }
    if (allApis.isNotEmpty) {
      final (apisClassRef, apisClass) = _beginClass(r'$_CelestApiResources');
      _library.body.add(lazySpec(apisClass.build));
      for (final MapEntry(key: apiName, value: environments)
          in allApis.entries) {
        final (apiClassRef, apiClass) = _generateApi(apiName, environments);
        apisClass.fields.add(
          Field(
            (b) => b
              ..name = apiName.camelCase
              ..modifier = FieldModifier.final$
              ..type = apiClassRef
              ..assignment = apiClassRef.constInstance([]).code,
          ),
        );
        _library.body.add(apiClass);
      }
      celestClass.fields.add(
        Field(
          (b) => b
            ..name = 'apis'
            ..modifier = FieldModifier.final$
            ..type = apisClassRef
            ..assignment = apisClassRef.constInstance([]).code,
        ),
      );
    }
    return _library.build();
  }
}
