import 'package:aws_common/aws_common.dart';
import 'package:celest_cli/ast/ast.dart';
import 'package:celest_cli/codegen/types.dart';
import 'package:celest_cli/src/utils/reference.dart';
import 'package:code_builder/code_builder.dart';

const _header = [
  'Generated by `celest start`. This file should not be modified manually, but',
  'it can be checked into version control.',
];

final class ResourceGenerator {
  ResourceGenerator(this.project);

  final Project project;
  final _library = LibraryBuilder()
    ..name = ''
    ..comments.addAll(_header);

  late final _celestClass = ClassBuilder()
    ..name = r'$_Celest'
    ..modifier = ClassModifier.final$;

  Class _generateApi(Api api) {
    final apiClass = ClassBuilder()
      ..name = '\$_${api.name.pascalCase}Api'
      ..modifier = ClassModifier.final$;
    for (final function in api.functions) {
      final inputParameters =
          function.parameters.where((p) => !p.type.isFunctionContext).toList();
      final inputType = switch (inputParameters) {
        [] => refer('void'),
        [final single] => single.type,
        final multiple => RecordType(
            (r) => r
              // TODO(dnys1): Treat all parameters the same (named/optional)?
              // This is only a Dart concept and we can handle the mapping to/from.
              // i.e. it does not affect the actual HTTP API.
              ..positionalFieldTypes.addAll([
                for (final parameter in multiple.where((p) => !p.named))
                  parameter.type,
              ])
              ..namedFieldTypes.addAll({
                for (final parameter in multiple.where((p) => p.named))
                  parameter.name: parameter.type,
              }),
          ),
      };
      final functionField = Field(
        (f) => f
          ..name = function.name.camelCase
          ..modifier = FieldModifier.final$
          ..assignment = DartTypes.celest
              .cloudFunction(
            inputType,
            function.flattenedReturnType,
          )
              .newInstance([], {
            'api': literalString(api.name, raw: true),
            'functionName': literalString(function.name, raw: true),
          }).code,
      );
      apiClass.fields.add(functionField);
    }
    return apiClass.build();
  }

  Library generate() {
    _library.body.add(
      Field(
        (b) => b
          ..name = 'celest'
          ..modifier = FieldModifier.final$
          ..type = refer(r'$_Celest')
          ..assignment = const Code(r'$_Celest()'),
      ),
    );
    if (project.apis.isNotEmpty) {
      final apisClass = ClassBuilder()
        ..name = r'$_CelestApis'
        ..modifier = ClassModifier.final$;
      for (final api in project.apis) {
        final apiClass = _generateApi(api);
        apisClass.fields.add(
          Field(
            (b) => b
              ..name = api.name.camelCase
              ..modifier = FieldModifier.final$
              ..type = refer(apiClass.name)
              ..assignment = refer(apiClass.name).newInstance([]).code,
          ),
        );
        _library.body.add(apiClass);
      }
      _celestClass.fields.add(
        Field(
          (b) => b
            ..name = 'apis'
            ..modifier = FieldModifier.final$
            ..type = refer(r'$_CelestApis')
            ..assignment = const Code(r'$_CelestApis()'),
        ),
      );
      _library.body.add(apisClass.build());
    }
    _library.body.add(_celestClass.build());
    return _library.build();
  }
}
