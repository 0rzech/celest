import 'package:aws_common/aws_common.dart';
import 'package:built_collection/built_collection.dart';
import 'package:celest_cli/ast/ast.dart';
import 'package:celest_cli/codegen/types.dart';
import 'package:celest_cli/src/utils/reference.dart';
import 'package:code_builder/code_builder.dart';

const _header = [
  'Generated by `celest start`. This file should not be modified manually, but',
  'it can be checked into version control.',
];

final class ResourcesGenerator {
  ResourcesGenerator({
    required this.project,
  });

  final Project project;
  final _library = LibraryBuilder()
    ..name = ''
    ..comments.addAll(_header);

  final _allResources = <String>{};

  final _classBuilders = <String, ClassBuilder>{};
  ClassBuilder _beginClass(String name) {
    final cached = _classBuilders[name];
    if (cached != null) {
      return cached;
    }
    final builder = ClassBuilder()
      ..name = name
      ..abstract = true
      ..modifier = ClassModifier.final$;
    _library.body.add(lazySpec(builder.build));
    return builder;
  }

  void _generateApi(
    Api api, {
    required MapBuilder<String, Field> apis,
    required MapBuilder<String, Field> functions,
  }) {
    final apiFieldName = api.name.camelCase;
    apis[apiFieldName] ??= Field(
      (f) => f
        ..static = true
        ..modifier = FieldModifier.constant
        ..name = api.name.camelCase
        ..assignment = DartTypes.celest.cloudApi.constInstance([], {
          'name': literalString(api.name, raw: true),
        }).code,
    );
    for (final function in api.functions.values) {
      final inputParameters =
          function.parameters.where((p) => !p.type.isFunctionContext).toList();
      final inputType = switch (inputParameters) {
        [] => refer('void'),
        [final single] => single.type,
        final multiple => RecordType(
            (r) => r
              // TODO(dnys1): Treat all parameters the same (named/optional)?
              // This is only a Dart concept and we can handle the mapping to/from.
              // i.e. it does not affect the actual HTTP API.
              ..positionalFieldTypes.addAll([
                for (final parameter in multiple.where((p) => !p.named))
                  parameter.type,
              ])
              ..namedFieldTypes.addAll({
                for (final parameter in multiple.where((p) => p.named))
                  parameter.name: parameter.type,
              }),
          ),
      };
      final functionFieldName = '${api.name}_${function.name}'.camelCase;
      functions[functionFieldName] ??= Field(
        (f) => f
          ..static = true
          ..name = functionFieldName
          ..modifier = FieldModifier.constant
          ..assignment = DartTypes.celest
              .cloudFunction(
            inputType,
            function.flattenedReturnType,
          )
              .constInstance([], {
            'api': literalString(api.name, raw: true),
            'functionName': literalString(function.name, raw: true),
          }).code,
      );
      _allResources.addAll([
        'apis.$apiFieldName',
        'functions.$functionFieldName',
      ]);
    }
  }

  Library generate() {
    final allApis = project.environments.values
        .expand((environment) => environment.apis.values);
    if (allApis.isNotEmpty) {
      final apis = MapBuilder<String, Field>();
      final functions = MapBuilder<String, Field>();
      for (final api in allApis) {
        _generateApi(
          api,
          apis: apis,
          functions: functions,
        );
      }
      _beginClass('apis').fields.addAll(apis.build().values);
      _beginClass('functions').fields.addAll(functions.build().values);
    }
    _library.body.add(
      Field(
        (f) => f
          ..type = DartTypes.core.list(DartTypes.celest.cloudWidget)
          ..name = 'all'
          ..assignment = literalConstList(
            _allResources.map(refer).toList(),
          ).code,
      ),
    );
    return _library.build();
  }
}
