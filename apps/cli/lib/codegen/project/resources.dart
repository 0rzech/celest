import 'package:aws_common/aws_common.dart';
import 'package:celest_cli/ast/ast.dart';
import 'package:celest_cli/codegen/types.dart';
import 'package:celest_cli/src/utils/reference.dart';
import 'package:code_builder/code_builder.dart';

const _header = [
  'Generated by `celest start`. This file should not be modified manually, but',
  'it can be checked into version control.',
];

final class ResourcesGenerator {
  ResourcesGenerator({
    required this.project,
  });

  final Project project;
  final _library = LibraryBuilder()
    ..name = ''
    ..comments.addAll(_header);

  (Reference, ClassBuilder) _beginClass(String name) => (
        refer(name),
        ClassBuilder()
          ..name = name
          ..modifier = ClassModifier.final$
          ..constructors.add(Constructor((c) => c..constant = true)),
      );

  (Reference, Class) _generateEnvironment(Environment environment) {
    final environmentName = environment.name!.pascalCase;
    final (environmentRef, environmentClass) =
        _beginClass('\$_Celest${environmentName}Resources');
    if (environment.apis.isNotEmpty) {
      final (apisClassRef, apisClass) =
          _beginClass('\$_Celest${environmentName}ApiResources');
      _library.body.add(lazySpec(apisClass.build));
      for (final api in environment.apis.values) {
        final (apiClassRef, apiClass) = _generateApi(api, environmentName);
        apisClass.fields.add(
          Field(
            (b) => b
              ..name = api.name.camelCase
              ..modifier = FieldModifier.final$
              ..type = apiClassRef
              ..assignment = apiClassRef.constInstance([]).code,
          ),
        );
        _library.body.add(apiClass);
      }
      environmentClass.fields.add(
        Field(
          (b) => b
            ..name = 'apis'
            ..modifier = FieldModifier.final$
            ..type = apisClassRef
            ..assignment = apisClassRef.constInstance([]).code,
        ),
      );
    }
    return (environmentRef, environmentClass.build());
  }

  (Reference, Class) _generateApi(Api api, String environmentName) {
    final apiClassName =
        '\$_Celest$environmentName${api.name.pascalCase}ApiResource';
    final (apiClassRef, apiClass) = _beginClass(apiClassName);
    for (final function in api.functions.values) {
      final inputParameters =
          function.parameters.where((p) => !p.type.isFunctionContext).toList();
      final inputType = switch (inputParameters) {
        [] => refer('void'),
        [final single] => single.type,
        final multiple => RecordType(
            (r) => r
              // TODO(dnys1): Treat all parameters the same (named/optional)?
              // This is only a Dart concept and we can handle the mapping to/from.
              // i.e. it does not affect the actual HTTP API.
              ..positionalFieldTypes.addAll([
                for (final parameter in multiple.where((p) => !p.named))
                  parameter.type,
              ])
              ..namedFieldTypes.addAll({
                for (final parameter in multiple.where((p) => p.named))
                  parameter.name: parameter.type,
              }),
          ),
      };
      final functionField = Field(
        (f) => f
          ..name = function.name.camelCase
          ..modifier = FieldModifier.final$
          ..assignment = DartTypes.celest
              .cloudFunction(
            inputType,
            function.flattenedReturnType,
          )
              .constInstance([], {
            'api': literalString(api.name, raw: true),
            'functionName': literalString(function.name, raw: true),
          }).code,
      );
      apiClass.fields.add(functionField);
    }
    return (apiClassRef, apiClass.build());
  }

  Library generate() {
    final (celestClassRef, celestClass) = _beginClass(r'$_CelestResources');
    _library.body.addAll([
      Field(
        (b) => b
          ..name = 'resources'
          ..modifier = FieldModifier.constant
          ..type = celestClassRef
          ..assignment = celestClassRef.constInstance([]).code,
      ),
      lazySpec(celestClass.build),
    ]);
    for (final environment in project.environments.values) {
      final (environmentRef, environmentClass) =
          _generateEnvironment(environment);
      celestClass.fields.add(
        Field(
          (b) => b
            ..name = environment.name!.camelCase
            ..modifier = FieldModifier.final$
            ..type = environmentRef
            ..assignment = environmentRef.constInstance([]).code,
        ),
      );
      _library.body.add(environmentClass);
    }
    return _library.build();
  }
}
