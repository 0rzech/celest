import 'package:celest_cli/init/project_items/add_generated_folder.dart';
import 'package:celest_cli/project/celest_project.dart';
import 'package:celest_cli/pub/project_dependency.dart';
import 'package:celest_cli/pub/pub_environment.dart';
import 'package:celest_cli/pub/pubspec.dart';
import 'package:celest_cli/src/context.dart';
import 'package:celest_cli/src/utils/error.dart';
import 'package:celest_cli/src/utils/run.dart';
import 'package:logging/logging.dart';
import 'package:pubspec_parse/pubspec_parse.dart';
import 'package:yaml/yaml.dart';
import 'package:yaml_edit/yaml_edit.dart';

abstract class ProjectItem {
  const ProjectItem();

  /// Creates the item in the given [projectRoot].
  Future<void> create(String projectRoot);
}

sealed class ProjectFile extends ProjectItem {
  const ProjectFile();

  const factory ProjectFile.gitIgnore() = _GitIgnore;

  const factory ProjectFile.analysisOptions() = _AnalysisOptions;

  const factory ProjectFile.pubspec(
    String projectName,
    ParentProject? parentProject,
  ) = PubspecFile;

  /// The relative path of the item from the project root.
  String get relativePath;
}

final class _GitIgnore extends ProjectFile {
  const _GitIgnore();

  @override
  String get relativePath => '.gitignore';

  @override
  Future<void> create(String projectRoot) async {
    await _createFile(
      p.join(projectRoot, relativePath),
      '''
# Dart
.dart_tool/
pubspec.lock

# Celest
**/.env
''',
    );
  }
}

final class _AnalysisOptions extends ProjectFile {
  const _AnalysisOptions();

  @override
  String get relativePath => 'analysis_options.yaml';

  @override
  Future<void> create(String projectRoot) async {
    await _createFile(
      p.join(projectRoot, relativePath),
      '''
include: package:lints/recommended.yaml

analyzer:
  errors:
    depend_on_referenced_packages: ignore
''',
    );
  }
}

final class PubspecFile extends ProjectFile {
  const PubspecFile(this.projectName, this.parentProject);

  final String projectName;
  final ParentProject? parentProject;

  static final logger = Logger('PubspecUpdater');

  @override
  String get relativePath => 'pubspec.yaml';

  /// Ensures app has dependency on celest project
  Future<void> _updateAppPubspec() async {
    final parentProject = this.parentProject;
    if (parentProject == null) {
      return;
    }
    const projectPubspecName = 'celest_backend';
    // final projectPubspecName = 'api_${projectName.snakeCase}';
    Object? updatedPubspec;
    if (parentProject.pubspec.dependencies.isEmpty) {
      final pubspecYaml = loadYamlNode(parentProject.pubspecYaml) as YamlMap;
      final replaceStart =
          switch (parentProject.pubspecYaml.indexOf('dependencies:')) {
        // Barebones pubspec, probably created by hand.
        -1 => pubspecYaml.nodes['environment']?.span.end.offset ??
            unreachable('No environment section in pubspec'),
        // Empty dependencies section generated by `dart create`. Replace with
        // ours.
        final dependenciesStart => dependenciesStart,
      };
      final replaceEnd =
          switch (parentProject.pubspecYaml.indexOf('dev_dependencies:')) {
        -1 => null,
        final devDependenciesStart => devDependenciesStart,
      };
      updatedPubspec = StringBuffer(
        parentProject.pubspecYaml.substring(0, replaceStart),
      )
        ..writeln()
        ..writeln('dependencies:')
        ..writeln('  $projectPubspecName:')
        ..writeln('    path: celest/')
        ..writeln(replaceEnd?.let(parentProject.pubspecYaml.substring) ?? '');
    } else if (!parentProject.pubspec.dependencies
        .containsKey(projectPubspecName)) {
      updatedPubspec = YamlEditor(parentProject.pubspecYaml)
        ..update(
          ['dependencies', projectPubspecName],
          {'path': 'celest/'},
        );
    }
    if (updatedPubspec != null) {
      await fileSystem
          .directory(parentProject.path)
          .childFile('pubspec.yaml')
          .writeAsString(updatedPubspec.toString());
    }
  }

  @override
  Future<void> create(String projectRoot) async {
    final file = fileSystem.file(p.join(projectRoot, relativePath));
    await file.create(recursive: true);

    // TODO(dnys1): Make this work with existing projects too
    var celestLocalPath = platform.environment['CELEST_LOCAL_PATH'];
    if (celestLocalPath != null) {
      celestLocalPath = p.canonicalize(p.normalize(celestLocalPath));
      if (fileSystem.directory(celestLocalPath).existsSync()) {
        logger.finest('Using local Celest at $celestLocalPath');
      } else {
        logger.warning(
          'CELEST_LOCAL_PATH is set to $celestLocalPath, but the directory '
          'does not exist. Ignoring.',
        );
        celestLocalPath = null;
      }
    }
    final pubspec = Pubspec(
      'celest_backend',
      // 'api_${projectName.snakeCase}',
      description: 'The Celest backend for $projectName.',
      publishTo: 'none',
      environment: {
        'sdk': PubEnvironment.dartSdkConstraint,
      },
      dependencies: ProjectDependency.dependencies,
      devDependencies: ProjectDependency.devDependencies,
      dependencyOverrides: switch (celestLocalPath) {
        null => null,
        final localPath => {
            'celest': PathDependency('$localPath/packages/celest'),
            'celest_core': PathDependency('$localPath/packages/celest_core'),
            'celest_auth': PathDependency('$localPath/packages/celest_auth'),
          },
      },
    );
    await file.writeAsString(pubspec.toYaml());
    await _updateAppPubspec();
  }
}

sealed class ProjectTemplate extends ProjectItem {
  const ProjectTemplate();

  factory ProjectTemplate.hello(String projectName) = _HelloProject;
}

final class _HelloProject extends ProjectTemplate {
  _HelloProject(this.projectName);

  final String projectName;

  @override
  Future<void> create(String projectRoot) async {
    await Future.wait([
      _createFile(
        projectPaths.projectDart,
        '''
import 'package:celest/celest.dart';

const project = Project(
  name: '$projectName',
);
''',
      ),
      _createFile(
        p.join(projectPaths.apisDir, 'greeting.dart'),
        r'''
// Cloud functions are top-level Dart functions defined in the `functions/`
// folder of your Celest project.

import 'package:celest/celest.dart';
import 'package:celest_backend/exceptions/bad_name_exception.dart';
import 'package:celest_backend/models/person.dart';

/// Says hello to a [person].
@cloud
Future<String> sayHello({required Person person}) async {
  if (person.name.isEmpty) {
    // Throw a custom exception defined in the `lib/exceptions/` and catch
    // it on the frontend.
    throw BadNameException('Name cannot be empty');
  }

  // Logging is handled automatically when you print to the console.
  print('Saying hello to ${person.name}');

  return 'Hello, ${person.name}!';
}
''',
      ),
      _createFile(
        p.join(projectRoot, 'test', 'functions', 'greeting_test.dart'),
        '''
import 'package:celest_backend/exceptions/bad_name_exception.dart';
import 'package:celest_backend/models/person.dart';
import 'package:test/test.dart';

import '../../functions/greeting.dart';

void main() {
  group('greeting', () {
    test('sayHello', () async {
      expect(await sayHello(person: Person(name: 'Celest')), 'Hello, Celest!');
    });
    test('sayHello (empty name)', () async {
      expect(
        sayHello(person: Person(name: '')),
        throwsA(isA<BadNameException>()),
      );
    });
  });
}
''',
      ),
      _createFile(
        p.join(projectRoot, 'lib', 'models', 'person.dart'),
        '''
// By convention, any custom types used within an API request/response must be
// defined in the `models/` folder.

class Person {
  const Person({required this.name});

  final String name;
}
''',
      ),
      _createFile(
        p.join(projectRoot, 'lib', 'exceptions', 'bad_name_exception.dart'),
        r'''
// By convention, any custom exception types thrown by an API must be defined
// in this file or exported from this file.

class BadNameException implements Exception {
  const BadNameException(this.message);

  final String message;

  @override
  String toString() => 'BadNameException: $message';
}
''',
      ),

      // Generated
      _createFile(
        p.join(projectPaths.generatedDir, 'README.md'),
        generated_README,
      ),
    ]);
  }
}

Future<void> _createFile(String path, String contents) async {
  final file = fileSystem.file(path);
  await file.create(recursive: true);
  await file.writeAsString(contents);
}
