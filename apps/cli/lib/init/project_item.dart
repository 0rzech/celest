import 'dart:io';

import 'package:celest_cli/src/sdk.dart';
import 'package:celest_cli/src/version.dart';
import 'package:path/path.dart' as p;

sealed class ProjectItem {
  const ProjectItem();

  /// Creates the item in the given [projectRoot].
  Future<void> create(String projectRoot);
}

sealed class ProjectFile extends ProjectItem {
  const ProjectFile();

  const factory ProjectFile.analysisOptions() = _AnalysisOptions;

  const factory ProjectFile.pubspec(String projectName) = _Pubspec;

  /// The relative path of the item from the project root.
  String get relativePath;
}

final class _AnalysisOptions extends ProjectFile {
  const _AnalysisOptions();

  @override
  String get relativePath => 'analysis_options.yaml';

  @override
  Future<void> create(String projectRoot) async {
    final file = File(p.join(projectRoot, relativePath));
    // TODO(dnys1): Generate analysis_options.yaml
    await file.writeAsString('''
    ''');
  }
}

final class _Pubspec extends ProjectFile {
  const _Pubspec(this.projectName);

  final String projectName;

  @override
  String get relativePath => 'pubspec.yaml';

  @override
  Future<void> create(String projectRoot) async {
    final file = File(p.join(projectRoot, relativePath));
    await file.writeAsString('''
name: $projectName
publish_to: none

environment:
  sdk: ^$dartSdkVersion

dependencies:
  celest: ^$packageVersion
''');
  }
}

sealed class ProjectTemplate extends ProjectItem {
  const ProjectTemplate();

  const factory ProjectTemplate.hello() = _HelloProject;
}

final class _HelloProject extends ProjectTemplate {
  const _HelloProject();

  @override
  Future<void> create(String projectRoot) async {
    final projectFile = File(p.join(projectRoot, 'project.dart'));
    await projectFile.writeAsString('''
import 'package:celest/celest.dart';

import 'generated.dart';

class HelloProject extends Project {
  @override
  List<String> get environments => ['prod'];

  @override
  void build(ProjectContext context) {
    // Our main Flutter application.
    final app = FlutterApp();

    // A simple function which says "Hello" and runs in the cloud.
    // The code can be found in `functions/say_hello.dart`.
    final sayHello = celest.functions.greeting.sayHello;

    // Resources are not automatically included in the generated client.
    // Here we add the sayHello function to the app so that it can be
    // called as follows:
    //
    // final result = await celest.functions.greeting.sayHello('World');
    app.use([sayHello]);
  }
}
''');

    final generatedFile = File(p.join(projectRoot, 'generated.dart'));
    await generatedFile.writeAsString(r'''
// Generated by `celest start`. This file should not be modified by hand
// but can be checked into version control.

import 'package:celest/celest.dart';

final celest = $_Celest();

final class $_Celest {
  final functions = $_CelestFunctions();
}

final class $_CelestFunctions {
  final greeting = $_GreetingApi();
}

final class $_GreetingApi {
  final sayHello = CloudFunction<String, String>(
    api: 'greeting',
    functionName: 'sayHello',
  );
}
''');

    final sayHelloFile =
        File(p.join(projectRoot, 'functions', 'say_hello.dart'));
    await sayHelloFile.create(recursive: true);
    await sayHelloFile.writeAsString(r'''
import 'package:celest/celest.dart';
import 'package:celest/middleware.dart' as middleware;

// Middleware are applied by adding annotations to your function.
//
// They allow reuse of code between functions and can be used for logging,
// authentication, authorization, and more.
@middleware.logRequests()
Future<String> sayHello(FunctionContext context, String name) async {
  return 'Hello, $name';
}
''');
  }
}
