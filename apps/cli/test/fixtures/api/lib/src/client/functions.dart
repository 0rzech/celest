// Generated by Celest. This file should not be modified manually, but
// it can be checked into version control.
// ignore_for_file: type=lint, unused_local_variable, unnecessary_cast, unnecessary_import

library; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:convert' as _$convert;
import 'dart:typed_data' as _$typed_data;

import 'package:celest/celest.dart';
import 'package:celest_backend/exceptions.dart';
import 'package:celest_backend/src/models/classes.dart';
import 'package:celest_backend/src/models/cycles.dart';
import 'package:celest_backend/src/models/exceptions.dart';
import 'package:celest_backend/src/models/extension_types.dart';
import 'package:celest_backend/src/models/generic_wrappers.dart';
import 'package:celest_backend/src/models/metadata.dart';
import 'package:celest_backend/src/models/parameter_types.dart';
import 'package:celest_backend/src/models/records.dart';
import 'package:celest_backend/src/models/sealed_classes.dart';
import 'package:celest_core/src/exception/cloud_exception.dart';
import 'package:celest_core/src/serialization/json_value.dart';
import 'package:fast_immutable_collections/src/ilist/ilist.dart' as _$ilist;
import 'package:fast_immutable_collections/src/imap/imap.dart' as _$imap;

import '../../client.dart';

class CelestFunctions {
  final asserts = CelestFunctionsAsserts();

  /// Tests that classes with and without explicit fromJson/toJson methods are
  /// serializable and deserializable.
  final classes = CelestFunctionsClasses();

  /// Tests that collections (e.g. Lists/Maps) can be used as parameter and
  /// return types.
  final collections = CelestFunctionsCollections();

  /// Tests that some cycles are allowed, e.g. when there is at least one level
  /// of indirection.
  final cycles = CelestFunctionsCycles();

  final exceptions = CelestFunctionsExceptions();

  /// Tests that extension types are correctly handled by the analyzer.
  final extensionTypes = CelestFunctionsExtensionTypes();

  /// Tests that classes which wrap generic types are generated correctly when
  /// those generic types follow the specifications of `json_serializable`, e.g.
  /// having a `toJson` method with function parameters for mapping the
  /// underlying types to JSON (Object Function(T) toJsonT).
  final genericWrappers = CelestFunctionsGenericWrappers();

  /// Tests that metadata associated with functions and parameters are correctly
  /// parsed and transferred to the generated client.
  final metadata = CelestFunctionsMetadata();

  final parameterTypes = CelestFunctionsParameterTypes();

  final parameters = CelestFunctionsParameters();

  /// Tests that records with and without aliases are serializable and
  /// deserializable.
  final records = CelestFunctionsRecords();

  /// Validates all permutations of return types.
  final returnTypes = CelestFunctionsReturnTypes();

  final sealedClasses = CelestFunctionsSealedClasses();
}

class CelestFunctionsAsserts {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// Tests that asserts are enabled when running the local API.
  Future<bool> assertsEnabled() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/asserts/asserts-enabled'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }
}

/// Tests that classes with and without explicit fromJson/toJson methods are
/// serializable and deserializable.
class CelestFunctionsClasses {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<Empty> empty(Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/empty'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'value': Serializers.instance.serialize<Empty>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Empty>($body['response']);
  }

  Future<Empty> asyncEmpty(Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-empty'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'value': Serializers.instance.serialize<Empty>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Empty>($body['response']);
  }

  Future<Fields> fields(Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Fields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Fields>($body['response']);
  }

  Future<Fields> asyncFields(Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Fields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Fields>($body['response']);
  }

  Future<Fields?> nullableFields(Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nullable-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Fields?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Fields?>($body['response']);
  }

  Future<Fields?> asyncNullableFields(Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nullable-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Fields?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Fields?>($body['response']);
  }

  Future<NamedFields> namedFields(NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NamedFields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NamedFields>($body['response']);
  }

  Future<NamedFields> asyncNamedFields(NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NamedFields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NamedFields>($body['response']);
  }

  Future<MixedFields> mixedFields(MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/mixed-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<MixedFields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<MixedFields>($body['response']);
  }

  Future<MixedFields> asyncMixedFields(MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-mixed-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<MixedFields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<MixedFields>($body['response']);
  }

  Future<DefaultValues> defaultValues(DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<DefaultValues>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<DefaultValues>($body['response']);
  }

  Future<DefaultValues> asyncDefaultValues(DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<DefaultValues>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<DefaultValues>($body['response']);
  }

  Future<NestedClass> nestedClass(NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nested-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NestedClass>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NestedClass>($body['response']);
  }

  Future<NestedClass> asyncNestedClass(NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nested-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NestedClass>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NestedClass>($body['response']);
  }

  Future<OnlyFromJson> onlyFromJson(OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<OnlyFromJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<OnlyFromJson>($body['response']);
  }

  Future<OnlyFromJson> asyncOnlyFromJson(OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<OnlyFromJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<OnlyFromJson>($body['response']);
  }

  Future<OnlyToJson> onlyToJson(OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<OnlyToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<OnlyToJson>($body['response']);
  }

  Future<OnlyToJson> asyncOnlyToJson(OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<OnlyToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<OnlyToJson>($body['response']);
  }

  Future<OnlyToJsonWithDefaults> onlyToJsonWithDefaults(
      OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<OnlyToJsonWithDefaults>($body['response']);
  }

  Future<OnlyToJsonWithDefaults> asyncOnlyToJsonWithDefaults(
      OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<OnlyToJsonWithDefaults>($body['response']);
  }

  Future<FromJsonAndToJson> fromAndToJson(FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<FromJsonAndToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<FromJsonAndToJson>($body['response']);
  }

  Future<FromJsonAndToJson> asyncFromAndToJson(FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<FromJsonAndToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<FromJsonAndToJson>($body['response']);
  }

  Future<NonMapToJson> nonMapToJson(NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NonMapToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NonMapToJson>($body['response']);
  }

  Future<NonMapToJson> asyncNonMapToJson(NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NonMapToJson>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NonMapToJson>($body['response']);
  }

  Future<NonMapToJsonWithDefaults> nonMapToJsonWithDefaults(
      NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NonMapToJsonWithDefaults>($body['response']);
  }

  Future<NonMapToJsonWithDefaults> asyncNonMapToJsonWithDefaults(
      NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NonMapToJsonWithDefaults>($body['response']);
  }

  Future<NonMapFromAndToJson> nonMapFromAndToJson(
      NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<NonMapFromAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NonMapFromAndToJson>($body['response']);
  }

  Future<NonMapFromAndToJson> asyncNonMapFromAndToJson(
      NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<NonMapFromAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NonMapFromAndToJson>($body['response']);
  }

  Future<FromJsonStatic> fromJsonStatic(FromJsonStatic value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<FromJsonStatic>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<FromJsonStatic>($body['response']);
  }
}

/// Tests that collections (e.g. Lists/Maps) can be used as parameter and
/// return types.
class CelestFunctionsCollections {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<List<String>> simpleList(List<String> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'list': list}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<SimpleClass>> complexList(List<SimpleClass> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'list': list
            .map((el) => Serializers.instance.serialize<SimpleClass>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<SimpleClass>(el))
        .toList();
  }

  Future<Map<String, String>> simpleMap(Map<String, String> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'map': map}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<Map<String, SimpleClass>> complexMap(
      Map<String, SimpleClass> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'map': map.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleClass>(value),
            ))
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          Serializers.instance.deserialize<SimpleClass>(value),
        ));
  }
}

/// Tests that some cycles are allowed, e.g. when there is at least one level
/// of indirection.
class CelestFunctionsCycles {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<Node> createTree() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/create-tree'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Node>($body['response']);
  }

  Future<void> printTree(Node node) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/print-tree'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'node': Serializers.instance.serialize<Node>(node)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<Node> combineTrees(
    Node tree1, [
    Parent? tree2 = null,
    Node? tree3 = null,
    List<Node?> additionalChildren = const [],
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/combine-trees'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'tree1': Serializers.instance.serialize<Node>(tree1),
        r'tree2': Serializers.instance.serialize<Parent?>(tree2),
        r'tree3': Serializers.instance.serialize<Node?>(tree3),
        r'additionalChildren': additionalChildren
            .map((el) => Serializers.instance.serialize<Node?>(el))
            .toList(),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Node>($body['response']);
  }

  /// Tests that self-referencing is allowed when there is a level
  /// of indirection, e.g. nullability, generics, or a wrapper.
  Future<SelfReferencing> selfReferencing(
      SelfReferencing selfReferencing) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/self-referencing'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'selfReferencing':
            Serializers.instance.serialize<SelfReferencing>(selfReferencing)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SelfReferencing>($body['response']);
  }
}

class CelestFunctionsExceptions {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'CustomException':
        throw Serializers.instance.deserialize<CustomException>($details);
      case r'CustomExceptionToFromJson':
        throw Serializers.instance
            .deserialize<CustomExceptionToFromJson>($details);
      case r'CustomError':
        throw Serializers.instance.deserialize<CustomError>($details);
      case r'CustomErrorToFromJson':
        throw Serializers.instance.deserialize<CustomErrorToFromJson>($details);
      case r'CustomErrorWithStackTrace':
        throw Serializers.instance
            .deserialize<CustomErrorWithStackTrace>($details);
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> throwsException({required SupportedExceptionType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'type': Serializers.instance.serialize<SupportedExceptionType>(type)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsError({required SupportedErrorType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-error'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'type': Serializers.instance.serialize<SupportedErrorType>(type)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomExceptionToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-exception-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomError() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomErrorToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomErrorWithStackTrace() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-error-with-stack-trace'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

/// Tests that extension types are correctly handled by the analyzer.
class CelestFunctionsExtensionTypes {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<StringX> string(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringX>(
          s,
          const TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringX>(
      $body['response'],
      const TypeToken<StringX>('StringX'),
    );
  }

  Future<StringX> asyncOrString(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-or-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringX>(
          s,
          const TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringX>(
      $body['response'],
      const TypeToken<StringX>('StringX'),
    );
  }

  Future<StringX> asyncString(StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringX>(
          s,
          const TypeToken<StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringX>(
      $body['response'],
      const TypeToken<StringX>('StringX'),
    );
  }

  Future<StringXImpl> stringImpl(StringXImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXImpl>(
          s,
          const TypeToken<StringXImpl>('StringXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXImpl>(
      $body['response'],
      const TypeToken<StringXImpl>('StringXImpl'),
    );
  }

  Future<StringXToFromJson> stringToFromJson(StringXToFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXToFromJson>(
          s,
          const TypeToken<StringXToFromJson>('StringXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXToFromJson>(
      $body['response'],
      const TypeToken<StringXToFromJson>('StringXToFromJson'),
    );
  }

  Future<StringXToJson> stringToJson(StringXToJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXToJson>(
          s,
          const TypeToken<StringXToJson>('StringXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXToJson>(
      $body['response'],
      const TypeToken<StringXToJson>('StringXToJson'),
    );
  }

  Future<StringXToJsonImpl> stringToJsonImpl(StringXToJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXToJsonImpl>(
          s,
          const TypeToken<StringXToJsonImpl>('StringXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXToJsonImpl>(
      $body['response'],
      const TypeToken<StringXToJsonImpl>('StringXToJsonImpl'),
    );
  }

  Future<StringXFromJson> stringFromJson(StringXFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXFromJson>(
          s,
          const TypeToken<StringXFromJson>('StringXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXFromJson>(
      $body['response'],
      const TypeToken<StringXFromJson>('StringXFromJson'),
    );
  }

  Future<StringXFromJsonImpl> stringFromJsonImpl(StringXFromJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXFromJsonImpl>(
          s,
          const TypeToken<StringXFromJsonImpl>('StringXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXFromJsonImpl>(
      $body['response'],
      const TypeToken<StringXFromJsonImpl>('StringXFromJsonImpl'),
    );
  }

  Future<StringXFromJsonStatic> stringFromJsonStatic(
      StringXFromJsonStatic s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXFromJsonStatic>(
          s,
          const TypeToken<StringXFromJsonStatic>('StringXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXFromJsonStatic>(
      $body['response'],
      const TypeToken<StringXFromJsonStatic>('StringXFromJsonStatic'),
    );
  }

  Future<StringXPrivateField> stringPrivateField(StringXPrivateField s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXPrivateField>(
          s,
          const TypeToken<StringXPrivateField>('StringXPrivateField'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXPrivateField>(
      $body['response'],
      const TypeToken<StringXPrivateField>('StringXPrivateField'),
    );
  }

  Future<StringXPrivateFieldImpl> stringPrivateFieldImpl(
      StringXPrivateFieldImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXPrivateFieldImpl>(
          s,
          const TypeToken<StringXPrivateFieldImpl>('StringXPrivateFieldImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXPrivateFieldImpl>(
      $body['response'],
      const TypeToken<StringXPrivateFieldImpl>('StringXPrivateFieldImpl'),
    );
  }

  Future<StringXPrivateCtor> stringPrivateCtor(StringXPrivateCtor s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXPrivateCtor>(
          s,
          const TypeToken<StringXPrivateCtor>('StringXPrivateCtor'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXPrivateCtor>(
      $body['response'],
      const TypeToken<StringXPrivateCtor>('StringXPrivateCtor'),
    );
  }

  Future<StringXPrivateCtorImpl> stringPrivateCtorImpl(
      StringXPrivateCtorImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<StringXPrivateCtorImpl>(
          s,
          const TypeToken<StringXPrivateCtorImpl>('StringXPrivateCtorImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<StringXPrivateCtorImpl>(
      $body['response'],
      const TypeToken<StringXPrivateCtorImpl>('StringXPrivateCtorImpl'),
    );
  }

  Future<Value> value(Value v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'v': Serializers.instance.serialize<Value>(v)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Value>($body['response']);
  }

  Future<ValueX> valuex(ValueX v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/valuex'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueX>(
          v,
          const TypeToken<ValueX>('ValueX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueX>(
      $body['response'],
      const TypeToken<ValueX>('ValueX'),
    );
  }

  Future<ValueXImpl> valueXImpl(ValueXImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXImpl>(
          v,
          const TypeToken<ValueXImpl>('ValueXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXImpl>(
      $body['response'],
      const TypeToken<ValueXImpl>('ValueXImpl'),
    );
  }

  Future<ValueXToFromJson> valueXToFromJson(ValueXToFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXToFromJson>(
          v,
          const TypeToken<ValueXToFromJson>('ValueXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXToFromJson>(
      $body['response'],
      const TypeToken<ValueXToFromJson>('ValueXToFromJson'),
    );
  }

  Future<ValueXToJson> valueXToJson(ValueXToJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXToJson>(
          v,
          const TypeToken<ValueXToJson>('ValueXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXToJson>(
      $body['response'],
      const TypeToken<ValueXToJson>('ValueXToJson'),
    );
  }

  Future<ValueXToJsonImpl> valueXToJsonImpl(ValueXToJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXToJsonImpl>(
          v,
          const TypeToken<ValueXToJsonImpl>('ValueXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXToJsonImpl>(
      $body['response'],
      const TypeToken<ValueXToJsonImpl>('ValueXToJsonImpl'),
    );
  }

  Future<ValueXFromJson> valueXFromJson(ValueXFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXFromJson>(
          v,
          const TypeToken<ValueXFromJson>('ValueXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXFromJson>(
      $body['response'],
      const TypeToken<ValueXFromJson>('ValueXFromJson'),
    );
  }

  Future<ValueXFromJsonImpl> valueXFromJsonImpl(ValueXFromJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXFromJsonImpl>(
          v,
          const TypeToken<ValueXFromJsonImpl>('ValueXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXFromJsonImpl>(
      $body['response'],
      const TypeToken<ValueXFromJsonImpl>('ValueXFromJsonImpl'),
    );
  }

  Future<ValueXFromJsonStatic> valueXFromJsonStatic(
      ValueXFromJsonStatic v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXFromJsonStatic>(
          v,
          const TypeToken<ValueXFromJsonStatic>('ValueXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXFromJsonStatic>(
      $body['response'],
      const TypeToken<ValueXFromJsonStatic>('ValueXFromJsonStatic'),
    );
  }

  /// Tests that extension types can implement other extension types to achieve
  /// the same results as above.
  Future<ValueXToFromJsonCombined> valueXToFromJsonCombined(
      ValueXToFromJsonCombined v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-from-json-combined'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXToFromJsonCombined>(
          v,
          const TypeToken<ValueXToFromJsonCombined>('ValueXToFromJsonCombined'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXToFromJsonCombined>(
      $body['response'],
      const TypeToken<ValueXToFromJsonCombined>('ValueXToFromJsonCombined'),
    );
  }

  Future<ValueXImplIndirect> valueXImplIndirect(ValueXImplIndirect v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-impl-indirect'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<ValueXImplIndirect>(
          v,
          const TypeToken<ValueXImplIndirect>('ValueXImplIndirect'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ValueXImplIndirect>(
      $body['response'],
      const TypeToken<ValueXImplIndirect>('ValueXImplIndirect'),
    );
  }

  Future<Color> color(Color color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'color': Serializers.instance.serialize<Color>(color)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Color>($body['response']);
  }

  Future<ColorX> colorx(ColorX color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/colorx'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorX>(
          color,
          const TypeToken<ColorX>('ColorX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorX>(
      $body['response'],
      const TypeToken<ColorX>('ColorX'),
    );
  }

  Future<ColorXImpl> colorXImpl(ColorXImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXImpl>(
          color,
          const TypeToken<ColorXImpl>('ColorXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXImpl>(
      $body['response'],
      const TypeToken<ColorXImpl>('ColorXImpl'),
    );
  }

  Future<ColorXToFromJson> colorXToFromJson(ColorXToFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXToFromJson>(
          color,
          const TypeToken<ColorXToFromJson>('ColorXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXToFromJson>(
      $body['response'],
      const TypeToken<ColorXToFromJson>('ColorXToFromJson'),
    );
  }

  Future<ColorXToJson> colorXToJson(ColorXToJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXToJson>(
          color,
          const TypeToken<ColorXToJson>('ColorXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXToJson>(
      $body['response'],
      const TypeToken<ColorXToJson>('ColorXToJson'),
    );
  }

  Future<ColorXToJsonImpl> colorXToJsonImpl(ColorXToJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXToJsonImpl>(
          color,
          const TypeToken<ColorXToJsonImpl>('ColorXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXToJsonImpl>(
      $body['response'],
      const TypeToken<ColorXToJsonImpl>('ColorXToJsonImpl'),
    );
  }

  Future<ColorXFromJson> colorXFromJson(ColorXFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXFromJson>(
          color,
          const TypeToken<ColorXFromJson>('ColorXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXFromJson>(
      $body['response'],
      const TypeToken<ColorXFromJson>('ColorXFromJson'),
    );
  }

  Future<ColorXFromJsonImpl> colorXFromJsonImpl(
      ColorXFromJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXFromJsonImpl>(
          color,
          const TypeToken<ColorXFromJsonImpl>('ColorXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXFromJsonImpl>(
      $body['response'],
      const TypeToken<ColorXFromJsonImpl>('ColorXFromJsonImpl'),
    );
  }

  Future<ColorXFromJsonStatic> colorXFromJsonStatic(
      ColorXFromJsonStatic color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXFromJsonStatic>(
          color,
          const TypeToken<ColorXFromJsonStatic>('ColorXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXFromJsonStatic>(
      $body['response'],
      const TypeToken<ColorXFromJsonStatic>('ColorXFromJsonStatic'),
    );
  }

  Future<ColorXToFromJsonCombined> colorXToFromJsonCombined(
      ColorXToFromJsonCombined color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-from-json-combined'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXToFromJsonCombined>(
          color,
          const TypeToken<ColorXToFromJsonCombined>('ColorXToFromJsonCombined'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXToFromJsonCombined>(
      $body['response'],
      const TypeToken<ColorXToFromJsonCombined>('ColorXToFromJsonCombined'),
    );
  }

  Future<ColorXImplIndirect> colorXImplIndirect(
      ColorXImplIndirect color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-impl-indirect'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<ColorXImplIndirect>(
          color,
          const TypeToken<ColorXImplIndirect>('ColorXImplIndirect'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ColorXImplIndirect>(
      $body['response'],
      const TypeToken<ColorXImplIndirect>('ColorXImplIndirect'),
    );
  }

  Future<JsonValue> jsonValue(JsonValue value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-value'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonValue>(
          value,
          const TypeToken<JsonValue>('JsonValue'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonValue>(
      $body['response'],
      const TypeToken<JsonValue>('JsonValue'),
    );
  }

  Future<JsonString> jsonString(JsonString value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonString>(
          value,
          const TypeToken<JsonString>('JsonString'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonString>(
      $body['response'],
      const TypeToken<JsonString>('JsonString'),
    );
  }

  Future<JsonNum> jsonNum(JsonNum value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-num'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonNum>(
          value,
          const TypeToken<JsonNum>('JsonNum'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonNum>(
      $body['response'],
      const TypeToken<JsonNum>('JsonNum'),
    );
  }

  Future<JsonInt> jsonInt(JsonInt value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-int'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonInt>(
          value,
          const TypeToken<JsonInt>('JsonInt'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonInt>(
      $body['response'],
      const TypeToken<JsonInt>('JsonInt'),
    );
  }

  Future<JsonDouble> jsonDouble(JsonDouble value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-double'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonDouble>(
          value,
          const TypeToken<JsonDouble>('JsonDouble'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonDouble>(
      $body['response'],
      const TypeToken<JsonDouble>('JsonDouble'),
    );
  }

  Future<JsonBool> jsonBool(JsonBool value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-bool'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonBool>(
          value,
          const TypeToken<JsonBool>('JsonBool'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonBool>(
      $body['response'],
      const TypeToken<JsonBool>('JsonBool'),
    );
  }

  Future<JsonList> jsonList(JsonList value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonList>(
          value,
          const TypeToken<JsonList>('JsonList'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonList>(
      $body['response'],
      const TypeToken<JsonList>('JsonList'),
    );
  }

  Future<JsonMap> jsonMap(JsonMap value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonMap>(
          value,
          const TypeToken<JsonMap>('JsonMap'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonMap>(
      $body['response'],
      const TypeToken<JsonMap>('JsonMap'),
    );
  }
}

/// Tests that classes which wrap generic types are generated correctly when
/// those generic types follow the specifications of `json_serializable`, e.g.
/// having a `toJson` method with function parameters for mapping the
/// underlying types to JSON (Object Function(T) toJsonT).
class CelestFunctionsGenericWrappers {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<GenericWrappers> genericWrappers(GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<GenericWrappers>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<GenericWrappers>($body['response']);
  }

  Future<GenericWrappers> genericWrappersAsync(GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers-async'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<GenericWrappers>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<GenericWrappers>($body['response']);
  }

  Future<GenericWrappers> genericWrapperParameters({
    required _$ilist.IList<String> listOfString,
    required _$ilist.IList<Uri> listOfUri,
    required _$ilist.IList<SimpleClass> listOfSimpleClass,
    required _$ilist.IList<_$ilist.IList<String>> listOfListOfString,
    required _$ilist.IList<_$ilist.IList<Uri>> listOfListOfUri,
    required _$ilist.IList<_$ilist.IList<SimpleClass>> listOfListOfSimpleClass,
    required _$imap.IMap<String, String> mapOfString,
    required _$imap.IMap<String, Uri> mapOfUri,
    required _$imap.IMap<String, SimpleClass> mapOfSimpleClass,
    required _$imap.IMap<String, _$ilist.IList<String>> mapOfListOfString,
    required _$imap.IMap<String, _$ilist.IList<Uri>> mapOfListOfUri,
    required _$imap.IMap<String, _$ilist.IList<SimpleClass>>
        mapOfListOfSimpleClass,
    required _$imap.IMap<String, _$imap.IMap<String, String>> mapOfMapOfString,
    required _$imap.IMap<String, _$imap.IMap<String, Uri>> mapOfMapOfUri,
    required _$imap.IMap<String, _$imap.IMap<String, SimpleClass>>
        mapOfMapOfSimpleClass,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrapper-parameters'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'listOfString':
            Serializers.instance.serialize<_$ilist.IList<String>>(listOfString),
        r'listOfUri':
            Serializers.instance.serialize<_$ilist.IList<Uri>>(listOfUri),
        r'listOfSimpleClass': Serializers.instance
            .serialize<_$ilist.IList<SimpleClass>>(listOfSimpleClass),
        r'listOfListOfString': Serializers.instance
            .serialize<_$ilist.IList<_$ilist.IList<String>>>(
                listOfListOfString),
        r'listOfListOfUri': Serializers.instance
            .serialize<_$ilist.IList<_$ilist.IList<Uri>>>(listOfListOfUri),
        r'listOfListOfSimpleClass': Serializers.instance
            .serialize<_$ilist.IList<_$ilist.IList<SimpleClass>>>(
                listOfListOfSimpleClass),
        r'mapOfString': Serializers.instance
            .serialize<_$imap.IMap<String, String>>(mapOfString),
        r'mapOfUri':
            Serializers.instance.serialize<_$imap.IMap<String, Uri>>(mapOfUri),
        r'mapOfSimpleClass': Serializers.instance
            .serialize<_$imap.IMap<String, SimpleClass>>(mapOfSimpleClass),
        r'mapOfListOfString': Serializers.instance
            .serialize<_$imap.IMap<String, _$ilist.IList<String>>>(
                mapOfListOfString),
        r'mapOfListOfUri': Serializers.instance
            .serialize<_$imap.IMap<String, _$ilist.IList<Uri>>>(mapOfListOfUri),
        r'mapOfListOfSimpleClass': Serializers.instance
            .serialize<_$imap.IMap<String, _$ilist.IList<SimpleClass>>>(
                mapOfListOfSimpleClass),
        r'mapOfMapOfString': Serializers.instance
            .serialize<_$imap.IMap<String, _$imap.IMap<String, String>>>(
                mapOfMapOfString),
        r'mapOfMapOfUri': Serializers.instance
            .serialize<_$imap.IMap<String, _$imap.IMap<String, Uri>>>(
                mapOfMapOfUri),
        r'mapOfMapOfSimpleClass': Serializers.instance
            .serialize<_$imap.IMap<String, _$imap.IMap<String, SimpleClass>>>(
                mapOfMapOfSimpleClass),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<GenericWrappers>($body['response']);
  }
}

/// Tests that metadata associated with functions and parameters are correctly
/// parsed and transferred to the generated client.
class CelestFunctionsMetadata {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// A function that has doc comments.
  ///
  /// This is a doc comment.
  ///
  /// # This is an H1
  /// ## This is an H2
  /// ### This is an H3
  /// * This is a list item
  ///
  /// This is an example:
  ///
  /// ```dart
  /// void hasDocComments() {}
  /// ```
  Future<void> hasDocComments() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-doc-comments'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  @Deprecated('next release')
  Future<void> hasDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-deprecated-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  @Deprecated('Do not use this function.')
  Future<void> hasConstructedDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-constructed-deprecated-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasNamedConstructedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-named-constructed-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasLiteralsAnnotation(
    String value, {
    required String named,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-literals-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasExportableAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasExportableConstructedAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-constructed-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasNotExportableAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-not-exportable-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValues([
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValues([
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-positional-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValues({
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValues({
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValueVars([
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValueVars([
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValueVars({
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValueVars({
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValueVarsPrivate([
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValueVarsPrivate([
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValueVarsPrivate({
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    LiteralEnum enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable exportable = const Exportable(),
    Serializable serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValueVarsPrivate({
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    LiteralEnum? enumValue = LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    Exportable? exportable = const Exportable(),
    Serializable? serializable = const Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-named-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue': Serializers.instance.serialize<LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable': Serializers.instance.serialize<Exportable?>(exportable),
        r'serializable':
            Serializers.instance.serialize<Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsParameterTypes {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> simple(
    String aString,
    int anInt,
    double aDouble,
    bool aBool,
    MyEnum anEnum,
    Null aNull,
    BigInt aBigInt,
    DateTime aDateTime,
    Duration aDuration,
    RegExp aRegExp,
    StackTrace aStackTrace,
    Uri aUri,
    UriData aUriData,
    _$typed_data.Uint8List aUint8List,
    Iterable<String> anIterableOfString,
    Iterable<_$typed_data.Uint8List> anIterableOfUint8List,
    List<String> aListOfString,
    List<int> aListOfInt,
    List<double> aListOfDouble,
    List<bool> aListOfBool,
    List<MyEnum> aListOfEnum,
    List<Null> aListOfNull,
    List<BigInt> aListOfBigInt,
    List<DateTime> aListOfDateTime,
    List<Duration> aListOfDuration,
    List<RegExp> aListOfRegExp,
    List<StackTrace> aListOfStackTrace,
    List<Uri> aListOfUri,
    List<UriData> aListOfUriData,
    List<_$typed_data.Uint8List> aListOfUint8List,
    Map<String, String> aMapOfString,
    Map<String, int> aMapOfInt,
    Map<String, double> aMapOfDouble,
    Map<String, bool> aMapOfBool,
    Map<String, MyEnum> aMapOfEnum,
    Map<String, Null> aMapOfNull,
    Map<String, BigInt> aMapOfBigInt,
    Map<String, DateTime> aMapOfDateTime,
    Map<String, Duration> aMapOfDuration,
    Map<String, RegExp> aMapOfRegExp,
    Map<String, StackTrace> aMapOfStackTrace,
    Map<String, Uri> aMapOfUri,
    Map<String, UriData> aMapOfUriData,
    Map<String, _$typed_data.Uint8List> aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum': Serializers.instance.serialize<MyEnum>(anEnum),
        r'aNull': aNull,
        r'aBigInt': Serializers.instance.serialize<BigInt>(aBigInt),
        r'aDateTime': Serializers.instance.serialize<DateTime>(aDateTime),
        r'aDuration': Serializers.instance.serialize<Duration>(aDuration),
        r'aRegExp': Serializers.instance.serialize<RegExp>(aRegExp),
        r'aStackTrace': Serializers.instance.serialize<StackTrace>(aStackTrace),
        r'aUri': Serializers.instance.serialize<Uri>(aUri),
        r'aUriData': Serializers.instance.serialize<UriData>(aUriData),
        r'aUint8List':
            Serializers.instance.serialize<_$typed_data.Uint8List>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            .map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            .map((el) => Serializers.instance.serialize<MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            .map((el) => Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            .map((el) => Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            .map((el) => Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            .map((el) => Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            .map((el) => Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            .map((el) => Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            .map((el) => Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            .map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$typed_data.Uint8List>(value),
            )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> simpleOptional(
    String? aString,
    int? anInt,
    double? aDouble,
    bool? aBool,
    MyEnum? anEnum,
    Null aNull,
    BigInt? aBigInt,
    DateTime? aDateTime,
    Duration? aDuration,
    RegExp? aRegExp,
    StackTrace? aStackTrace,
    Uri? aUri,
    UriData? aUriData,
    _$typed_data.Uint8List? aUint8List,
    Iterable<String>? anIterableOfString,
    Iterable<_$typed_data.Uint8List>? anIterableOfUint8List,
    List<String>? aListOfString,
    List<int>? aListOfInt,
    List<double>? aListOfDouble,
    List<bool>? aListOfBool,
    List<MyEnum>? aListOfEnum,
    List<Null>? aListOfNull,
    List<BigInt>? aListOfBigInt,
    List<DateTime>? aListOfDateTime,
    List<Duration>? aListOfDuration,
    List<RegExp>? aListOfRegExp,
    List<StackTrace>? aListOfStackTrace,
    List<Uri>? aListOfUri,
    List<UriData>? aListOfUriData,
    List<_$typed_data.Uint8List>? aListOfUint8List,
    Map<String, String>? aMapOfString,
    Map<String, int>? aMapOfInt,
    Map<String, double>? aMapOfDouble,
    Map<String, bool>? aMapOfBool,
    Map<String, MyEnum>? aMapOfEnum,
    Map<String, Null>? aMapOfNull,
    Map<String, BigInt>? aMapOfBigInt,
    Map<String, DateTime>? aMapOfDateTime,
    Map<String, Duration>? aMapOfDuration,
    Map<String, RegExp>? aMapOfRegExp,
    Map<String, StackTrace>? aMapOfStackTrace,
    Map<String, Uri>? aMapOfUri,
    Map<String, UriData>? aMapOfUriData,
    Map<String, _$typed_data.Uint8List>? aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple-optional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum': Serializers.instance.serialize<MyEnum?>(anEnum),
        r'aNull': aNull,
        r'aBigInt': Serializers.instance.serialize<BigInt?>(aBigInt),
        r'aDateTime': Serializers.instance.serialize<DateTime?>(aDateTime),
        r'aDuration': Serializers.instance.serialize<Duration?>(aDuration),
        r'aRegExp': Serializers.instance.serialize<RegExp?>(aRegExp),
        r'aStackTrace':
            Serializers.instance.serialize<StackTrace?>(aStackTrace),
        r'aUri': Serializers.instance.serialize<Uri?>(aUri),
        r'aUriData': Serializers.instance.serialize<UriData?>(aUriData),
        r'aUint8List':
            Serializers.instance.serialize<_$typed_data.Uint8List?>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            ?.map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            ?.map((el) => Serializers.instance.serialize<MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            ?.map((el) => Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            ?.map((el) => Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            ?.map((el) => Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            ?.map((el) => Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            ?.map((el) => Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            ?.map((el) => Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            ?.map((el) => Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            ?.map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$typed_data.Uint8List>(value),
            )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> complex(
    SimpleStruct aSimpleStruct,
    ComplexStruct aComplexStruct,
    SimpleClass aSimpleClass,
    ComplexClass aComplexClass,
    SimpleStruct? aNullableSimpleStruct,
    ComplexStruct? aNullableComplexStruct,
    SimpleClass? aNullableSimpleClass,
    ComplexClass? aNullableComplexClass,
    Iterable<SimpleStruct> anIterableOfSimpleStruct,
    Iterable<ComplexStruct> anIterableOfComplexStruct,
    Iterable<SimpleClass> anIterableOfSimpleClass,
    Iterable<ComplexClass> anIterableOfComplexClass,
    Iterable<SimpleStruct>? aNullableIterableOfSimpleStruct,
    Iterable<ComplexStruct>? aNullableIterableOfComplexStruct,
    Iterable<SimpleClass>? aNullableIterableOfSimpleClass,
    Iterable<ComplexClass>? aNullableIterableOfComplexClass,
    Iterable<SimpleStruct?> anIterableOfNullableSimpleStruct,
    Iterable<ComplexStruct?> anIterableOfNullableComplexStruct,
    Iterable<SimpleClass?> anIterableOfNullableSimpleClass,
    Iterable<ComplexClass?> anIterableOfNullableComplexClass,
    List<SimpleStruct> aListOfSimpleStruct,
    List<ComplexStruct> aListOfComplexStruct,
    List<SimpleClass> aListOfSimpleClass,
    List<ComplexClass> aListOfComplexClass,
    List<SimpleStruct>? aNullableListOfSimpleStruct,
    List<ComplexStruct>? aNullableListOfComplexStruct,
    List<SimpleClass>? aNullableListOfSimpleClass,
    List<ComplexClass>? aNullableListOfComplexClass,
    List<SimpleStruct?> aListOfNullableSimpleStruct,
    List<ComplexStruct?> aListOfNullableComplexStruct,
    List<SimpleClass?> aListOfNullableSimpleClass,
    List<ComplexClass?> aListOfNullableComplexClass,
    Map<String, SimpleStruct> aMapOfSimpleStruct,
    Map<String, ComplexStruct> aMapOfComplexStruct,
    Map<String, SimpleClass> aMapOfSimpleClass,
    Map<String, ComplexClass> aMapOfComplexClass,
    Map<String, SimpleStruct>? aNullableMapOfSimpleStruct,
    Map<String, ComplexStruct>? aNullableMapOfComplexStruct,
    Map<String, SimpleClass>? aNullableMapOfSimpleClass,
    Map<String, ComplexClass>? aNullableMapOfComplexClass,
    Map<String, SimpleStruct?> aMapOfNullableSimpleStruct,
    Map<String, ComplexStruct?> aMapOfNullableComplexStruct,
    Map<String, SimpleClass?> aMapOfNullableSimpleClass,
    Map<String, ComplexClass?> aMapOfNullableComplexClass,
    Map<String, SimpleStruct?>? aNullableMapOfNullableSimpleStruct,
    Map<String, ComplexStruct?>? aNullableMapOfNullableComplexStruct,
    Map<String, SimpleClass?>? aNullableMapOfNullableSimpleClass,
    Map<String, ComplexClass?>? aNullableMapOfNullableComplexClass,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/complex'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aSimpleStruct':
            Serializers.instance.serialize<SimpleStruct>(aSimpleStruct),
        r'aComplexStruct':
            Serializers.instance.serialize<ComplexStruct>(aComplexStruct),
        r'aSimpleClass':
            Serializers.instance.serialize<SimpleClass>(aSimpleClass),
        r'aComplexClass':
            Serializers.instance.serialize<ComplexClass>(aComplexClass),
        r'aNullableSimpleStruct': Serializers.instance
            .serialize<SimpleStruct?>(aNullableSimpleStruct),
        r'aNullableComplexStruct': Serializers.instance
            .serialize<ComplexStruct?>(aNullableComplexStruct),
        r'aNullableSimpleClass':
            Serializers.instance.serialize<SimpleClass?>(aNullableSimpleClass),
        r'aNullableComplexClass': Serializers.instance
            .serialize<ComplexClass?>(aNullableComplexClass),
        r'anIterableOfSimpleStruct': anIterableOfSimpleStruct
            .map((el) => Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'anIterableOfComplexStruct': anIterableOfComplexStruct
            .map((el) => Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'anIterableOfSimpleClass': anIterableOfSimpleClass
            .map((el) => Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'anIterableOfComplexClass': anIterableOfComplexClass
            .map((el) => Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aNullableIterableOfSimpleStruct': aNullableIterableOfSimpleStruct
            ?.map((el) => Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aNullableIterableOfComplexStruct': aNullableIterableOfComplexStruct
            ?.map((el) => Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aNullableIterableOfSimpleClass': aNullableIterableOfSimpleClass
            ?.map((el) => Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aNullableIterableOfComplexClass': aNullableIterableOfComplexClass
            ?.map((el) => Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'anIterableOfNullableSimpleStruct': anIterableOfNullableSimpleStruct
            .map((el) => Serializers.instance.serialize<SimpleStruct?>(el))
            .toList(),
        r'anIterableOfNullableComplexStruct': anIterableOfNullableComplexStruct
            .map((el) => Serializers.instance.serialize<ComplexStruct?>(el))
            .toList(),
        r'anIterableOfNullableSimpleClass': anIterableOfNullableSimpleClass
            .map((el) => Serializers.instance.serialize<SimpleClass?>(el))
            .toList(),
        r'anIterableOfNullableComplexClass': anIterableOfNullableComplexClass
            .map((el) => Serializers.instance.serialize<ComplexClass?>(el))
            .toList(),
        r'aListOfSimpleStruct': aListOfSimpleStruct
            .map((el) => Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aListOfComplexStruct': aListOfComplexStruct
            .map((el) => Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aListOfSimpleClass': aListOfSimpleClass
            .map((el) => Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aListOfComplexClass': aListOfComplexClass
            .map((el) => Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aNullableListOfSimpleStruct': aNullableListOfSimpleStruct
            ?.map((el) => Serializers.instance.serialize<SimpleStruct>(el))
            .toList(),
        r'aNullableListOfComplexStruct': aNullableListOfComplexStruct
            ?.map((el) => Serializers.instance.serialize<ComplexStruct>(el))
            .toList(),
        r'aNullableListOfSimpleClass': aNullableListOfSimpleClass
            ?.map((el) => Serializers.instance.serialize<SimpleClass>(el))
            .toList(),
        r'aNullableListOfComplexClass': aNullableListOfComplexClass
            ?.map((el) => Serializers.instance.serialize<ComplexClass>(el))
            .toList(),
        r'aListOfNullableSimpleStruct': aListOfNullableSimpleStruct
            .map((el) => Serializers.instance.serialize<SimpleStruct?>(el))
            .toList(),
        r'aListOfNullableComplexStruct': aListOfNullableComplexStruct
            .map((el) => Serializers.instance.serialize<ComplexStruct?>(el))
            .toList(),
        r'aListOfNullableSimpleClass': aListOfNullableSimpleClass
            .map((el) => Serializers.instance.serialize<SimpleClass?>(el))
            .toList(),
        r'aListOfNullableComplexClass': aListOfNullableComplexClass
            .map((el) => Serializers.instance.serialize<ComplexClass?>(el))
            .toList(),
        r'aMapOfSimpleStruct': aMapOfSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleStruct>(value),
            )),
        r'aMapOfComplexStruct': aMapOfComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexStruct>(value),
            )),
        r'aMapOfSimpleClass': aMapOfSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleClass>(value),
            )),
        r'aMapOfComplexClass': aMapOfComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexClass>(value),
            )),
        r'aNullableMapOfSimpleStruct': aNullableMapOfSimpleStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleStruct>(value),
            )),
        r'aNullableMapOfComplexStruct': aNullableMapOfComplexStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexStruct>(value),
            )),
        r'aNullableMapOfSimpleClass': aNullableMapOfSimpleClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleClass>(value),
            )),
        r'aNullableMapOfComplexClass': aNullableMapOfComplexClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexClass>(value),
            )),
        r'aMapOfNullableSimpleStruct': aMapOfNullableSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleStruct?>(value),
            )),
        r'aMapOfNullableComplexStruct': aMapOfNullableComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexStruct?>(value),
            )),
        r'aMapOfNullableSimpleClass': aMapOfNullableSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<SimpleClass?>(value),
            )),
        r'aMapOfNullableComplexClass': aMapOfNullableComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<ComplexClass?>(value),
            )),
        r'aNullableMapOfNullableSimpleStruct':
            aNullableMapOfNullableSimpleStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance.serialize<SimpleStruct?>(value),
                )),
        r'aNullableMapOfNullableComplexStruct':
            aNullableMapOfNullableComplexStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance.serialize<ComplexStruct?>(value),
                )),
        r'aNullableMapOfNullableSimpleClass':
            aNullableMapOfNullableSimpleClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance.serialize<SimpleClass?>(value),
                )),
        r'aNullableMapOfNullableComplexClass':
            aNullableMapOfNullableComplexClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance.serialize<ComplexClass?>(value),
                )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsParameters {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> optionalPositional([
    String? optionalString = null,
    int? optionalInt = null,
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-positional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'optionalString': optionalString,
        r'optionalInt': optionalInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> optionalNamed({
    String? namedString = null,
    int? namedInt = null,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-named'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'namedString': namedString,
        r'namedInt': namedInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> requiredPositional(
    String requiredString,
    int requiredInt,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-positional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> requiredNamed({
    required String requiredString,
    required int requiredInt,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-named'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

/// Tests that records with and without aliases are serializable and
/// deserializable.
class CelestFunctionsRecords {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<({String anotherField, String field})> nonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/non-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<({String anotherField, String field})>($body['response']);
  }

  Future<({String anotherField, String field})> asyncNonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-non-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<({String anotherField, String field})>($body['response']);
  }

  Future<NamedFieldsRecord> aliasedNamedFields(
      {required NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NamedFieldsRecord>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NamedFieldsRecord>($body['response']);
  }

  Future<NamedFieldsRecord> asyncAliasedNamedFields(
      {required NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NamedFieldsRecord>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<NamedFieldsRecord>($body['response']);
  }

  Future<
      ({
        NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> namedFields({
    required ({String anotherField, String field}) nonAliased,
    required NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'nonAliased': Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased': Serializers.instance.serialize<NamedFieldsRecord>(aliased),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body['response']);
  }

  Future<
      ({
        NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> asyncNamedFields({
    required ({String anotherField, String field}) nonAliased,
    required NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'nonAliased': Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased': Serializers.instance.serialize<NamedFieldsRecord>(aliased),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body['response']);
  }

  Future<Nested> nested(Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Nested>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Nested>($body['response']);
  }

  Future<Nested> asyncNested(Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<Nested>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Nested>($body['response']);
  }

  Future<NullableNested?> nullableNested(NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nullable-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NullableNested?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NullableNested?>($body['response']);
  }

  Future<NullableNested?> asyncNullableNested(NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nullable-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<NullableNested?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<NullableNested?>($body['response']);
  }
}

/// Validates all permutations of return types.
class CelestFunctionsReturnTypes {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> asyncVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> asyncStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> asyncIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> asyncDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> asyncBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> asyncIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> asyncListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> asyncMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<SimpleStruct> asyncStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct>($body['response']);
  }

  Future<SimpleStruct?> asyncStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct?>($body['response']);
  }

  Future<ComplexStruct> asyncComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct>($body['response']);
  }

  Future<ComplexStruct?> asyncComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-complex-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct?>($body['response']);
  }

  Future<ComplexClass> asyncComplexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexClass>($body['response']);
  }

  Future<SimpleClass?> asyncClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleClass?>($body['response']);
  }

  Future<void> asyncOrVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> asyncOrStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> asyncOrIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> asyncOrDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> asyncOrBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> asyncOrIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> asyncOrListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> asyncOrMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<SimpleStruct> asyncOrStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct>($body['response']);
  }

  Future<ComplexStruct> asyncOrComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-complex-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct>($body['response']);
  }

  Future<void> asyncOrVoidReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String?> asyncOrStringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String?);
  }

  Future<int?> asyncOrIntReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toInt();
  }

  Future<double?> asyncOrDoubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toDouble();
  }

  Future<bool?> asyncOrBoolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool?);
  }

  Future<Iterable<String>?> asyncOrIterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<List<String>?> asyncOrListReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>?> asyncOrMapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<SimpleStruct?> asyncOrStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct?>($body['response']);
  }

  Future<ComplexStruct?> asyncOrComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct?>($body['response']);
  }

  Future<SimpleClass?> asyncOrSimpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-simple-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleClass?>($body['response']);
  }

  Future<ComplexClass?> asyncOrComplexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexClass?>($body['response']);
  }

  Future<void> voidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> stringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> intReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> doubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> boolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> iterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> listReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> mapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<SimpleStruct> structReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct>($body['response']);
  }

  Future<ComplexStruct> complexReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct>($body['response']);
  }

  Future<SimpleClass> simpleClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleClass>($body['response']);
  }

  Future<ComplexClass> complexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexClass>($body['response']);
  }

  Future<String?> stringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String?);
  }

  Future<int?> intReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toInt();
  }

  Future<double?> doubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toDouble();
  }

  Future<bool?> boolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool?);
  }

  Future<Iterable<String>?> iterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<List<String>?> listReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>?> mapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<SimpleStruct?> structReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleStruct?>($body['response']);
  }

  Future<ComplexStruct?> complexReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexStruct?>($body['response']);
  }

  Future<SimpleClass?> simpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<SimpleClass?>($body['response']);
  }

  Future<ComplexClass?> complexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<ComplexClass?>($body['response']);
  }
}

class CelestFunctionsSealedClasses {
  Never _handleError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'CustomException':
        throw Serializers.instance.deserialize<CustomException>($details);
      case r'CustomExceptionToFromJson':
        throw Serializers.instance
            .deserialize<CustomExceptionToFromJson>($details);
      case r'CustomError':
        throw Serializers.instance.deserialize<CustomError>($details);
      case r'CustomErrorToFromJson':
        throw Serializers.instance.deserialize<CustomErrorToFromJson>($details);
      case r'CustomErrorWithStackTrace':
        throw Serializers.instance
            .deserialize<CustomErrorWithStackTrace>($details);
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'InternalServerException':
        throw Serializers.instance
            .deserialize<InternalServerException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<double> area(Shape shape) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/area'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert
          .jsonEncode({r'shape': Serializers.instance.serialize<Shape>(shape)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<List<Shape>> sealedClass({required List<Shape> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<Shape>(el))
        .toList();
  }

  Future<Rectangle> rectangle(Rectangle rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/rectangle'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'rectangle': Serializers.instance.serialize<Rectangle>(rectangle)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Rectangle>($body['response']);
  }

  Future<Circle> circle(Circle circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/circle'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'circle': Serializers.instance.serialize<Circle>(circle)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<Circle>($body['response']);
  }

  Future<List<ShapeWithInheritedCustomJson>> sealedClassWithInheritedCustomJson(
      {required List<ShapeWithInheritedCustomJson> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-inherited-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance
                .serialize<ShapeWithInheritedCustomJson>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) =>
            Serializers.instance.deserialize<ShapeWithInheritedCustomJson>(el))
        .toList();
  }

  Future<List<ShapeWithCustomJson>> sealedClassWithCustomJson(
      {required List<ShapeWithCustomJson> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class-with-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map(
                (el) => Serializers.instance.serialize<ShapeWithCustomJson>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<ShapeWithCustomJson>(el))
        .toList();
  }

  Future<List<ShapeWithOverriddenCustomJson>>
      sealedClassWithOverriddenCustomJson({
    required CircleWithOverriddenCustomJson circle,
    required RectangleWithOverriddenCustomJson rectangle,
    required List<ShapeWithOverriddenCustomJson> other,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'circle': Serializers.instance
            .serialize<CircleWithOverriddenCustomJson>(circle),
        r'rectangle': Serializers.instance
            .serialize<RectangleWithOverriddenCustomJson>(rectangle),
        r'other': other
            .map((el) => Serializers.instance
                .serialize<ShapeWithOverriddenCustomJson>(el))
            .toList(),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) =>
            Serializers.instance.deserialize<ShapeWithOverriddenCustomJson>(el))
        .toList();
  }

  Future<ShapeWithOverriddenCustomJson> rectangleWithOverriddenCustomJson(
      RectangleWithOverriddenCustomJson rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/rectangle-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'rectangle': Serializers.instance
            .serialize<RectangleWithOverriddenCustomJson>(rectangle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<ShapeWithOverriddenCustomJson>($body['response']);
  }

  Future<CircleWithOverriddenCustomJson> circleWithOverriddenCustomJson(
      ShapeWithOverriddenCustomJson circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/circle-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'circle': Serializers.instance
            .serialize<ShapeWithOverriddenCustomJson>(circle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<CircleWithOverriddenCustomJson>($body['response']);
  }

  Future<List<OkResult<Shape>>> okShapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/ok-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<OkResult<Shape>>(el))
        .toList();
  }

  Future<List<ErrResult<String>>> errShapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/err-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<ErrResult<String>>(el))
        .toList();
  }

  Future<List<Result<Shape, String>>> shapeResults(List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map(
            (el) => Serializers.instance.deserialize<Result<Shape, String>>(el))
        .toList();
  }

  Future<List<Result<Shape, String>>> aliasedOkShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-ok-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map(
            (el) => Serializers.instance.deserialize<Result<Shape, String>>(el))
        .toList();
  }

  Future<List<Result<Shape, String>>> aliasedErrShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-err-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map(
            (el) => Serializers.instance.deserialize<Result<Shape, String>>(el))
        .toList();
  }

  Future<List<Result<Shape, String>>> aliasedShapeResults(
      List<Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance.serialize<Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map(
            (el) => Serializers.instance.deserialize<Result<Shape, String>>(el))
        .toList();
  }

  Future<SwappedResult<Shape, String>> swappedResult(
      Result<Shape, String> result) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/swapped-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'result': Serializers.instance.serialize<Result<Shape, String>>(result)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<SwappedResult<Shape, String>>($body['response']);
  }

  Future<OkResult<T>> genericResult<T extends Shape>(T data) async {
    const $T = {
      Shape: r'Shape',
      Rectangle: r'Rectangle',
      Circle: r'Circle',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/generic-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'$T': $T[T]!,
        r'data': Serializers.instance.serialize<T>(data),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<OkResult<T>>($body['response']);
  }

  Future<List<Result<T, E>>>
      multipleGenericResult<T extends Shape, E extends ShapeException>(
    T data,
    E error,
  ) async {
    const $T = {
      Shape: r'Shape',
      Rectangle: r'Rectangle',
      Circle: r'Circle',
    };
    const $E = {
      ShapeException: r'ShapeException',
      BadShapeException: r'BadShapeException',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/multiple-generic-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'$T': $T[T]!,
        r'$E': $E[E]!,
        r'data': Serializers.instance.serialize<T>(data),
        r'error': Serializers.instance.serialize<E>(error),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _handleError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<Result<T, E>>(el))
        .toList();
  }
}
