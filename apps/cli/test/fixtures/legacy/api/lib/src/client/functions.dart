// Generated by Celest. This file should not be modified manually, but
// it can be checked into version control.
// ignore_for_file: type=lint, unused_local_variable, unnecessary_cast, unnecessary_import

library; // ignore_for_file: no_leading_underscores_for_library_prefixes

import 'dart:convert' as _$convert;
import 'dart:typed_data' as _$typed_data;

import 'package:_common/_common.dart' as _$_common;
import 'package:celest/celest.dart';
import 'package:celest_backend/exceptions/demo.dart' as _$demo;
import 'package:celest_backend/exceptions/exceptions.dart' as _$exceptions;
import 'package:celest_backend/exceptions/overrides.dart' as _$overrides;
import 'package:celest_backend/models/classes.dart' as _$classes;
import 'package:celest_backend/models/cycles.dart' as _$cycles;
import 'package:celest_backend/models/demo.dart' as _$demo;
import 'package:celest_backend/models/exceptions.dart' as _$exceptions;
import 'package:celest_backend/models/extension_types.dart'
    as _$extension_types;
import 'package:celest_backend/models/generic_wrappers.dart'
    as _$generic_wrappers;
import 'package:celest_backend/models/metadata.dart' as _$metadata;
import 'package:celest_backend/models/overrides.dart' as _$overrides;
import 'package:celest_backend/models/parameter_types.dart'
    as _$parameter_types;
import 'package:celest_backend/models/records.dart' as _$records;
import 'package:celest_backend/models/sealed_classes.dart' as _$sealed_classes;
import 'package:celest_backend/models/typedefs.dart' as _$typedefs;
import 'package:celest_core/src/exception/cloud_exception.dart';
import 'package:celest_core/src/exception/serialization_exception.dart';
import 'package:celest_core/src/serialization/json_value.dart';
import 'package:fast_immutable_collections/src/ilist/ilist.dart' as _$ilist;
import 'package:fast_immutable_collections/src/imap/imap.dart' as _$imap;

import '../../client.dart';

class CelestFunctions {
  final asserts = CelestFunctionsAsserts();

  /// Tests that classes with and without explicit fromJson/toJson methods are
  /// serializable and deserializable.
  final classes = CelestFunctionsClasses();

  /// Tests that collections (e.g. Lists/Maps) can be used as parameter and
  /// return types.
  final collections = CelestFunctionsCollections();

  /// Tests that some cycles are allowed, e.g. when there is at least one level
  /// of indirection.
  final cycles = CelestFunctionsCycles();

  final demo = CelestFunctionsDemo();

  final exceptions = CelestFunctionsExceptions();

  /// Tests that extension types are correctly handled by the analyzer.
  final extensionTypes = CelestFunctionsExtensionTypes();

  /// Tests that classes which wrap generic types are generated correctly when
  /// those generic types follow the specifications of `json_serializable`, e.g.
  /// having a `toJson` method with function parameters for mapping the
  /// underlying types to JSON (Object Function(T) toJsonT).
  final genericWrappers = CelestFunctionsGenericWrappers();

  /// Tests that metadata associated with functions and parameters are correctly
  /// parsed and transferred to the generated client.
  final metadata = CelestFunctionsMetadata();

  /// Tests that types can be recursively overriden in the serialization protocol
  /// using extension types.
  final overrides = CelestFunctionsOverrides();

  final parameterTypes = CelestFunctionsParameterTypes();

  final parameters = CelestFunctionsParameters();

  /// Tests that records with and without aliases are serializable and
  /// deserializable.
  final records = CelestFunctionsRecords();

  /// Validates all permutations of return types.
  final returnTypes = CelestFunctionsReturnTypes();

  final sealedClasses = CelestFunctionsSealedClasses();

  /// Checks that typedefs work as expected.
  final typedefs = CelestFunctionsTypedefs();
}

class CelestFunctionsAsserts {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// Tests that asserts are enabled when running the local API.
  Future<bool> assertsEnabled() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/asserts/asserts-enabled'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }
}

/// Tests that classes with and without explicit fromJson/toJson methods are
/// serializable and deserializable.
class CelestFunctionsClasses {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$classes.Empty> empty(_$classes.Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/empty'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Empty>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$classes.Empty>($body['response']);
  }

  Future<_$classes.Empty> asyncEmpty(_$classes.Empty value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-empty'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Empty>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$classes.Empty>($body['response']);
  }

  Future<_$classes.Fields> fields(_$classes.Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Fields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.Fields>($body['response']);
  }

  Future<_$classes.Fields> asyncFields(_$classes.Fields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Fields>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.Fields>($body['response']);
  }

  Future<_$classes.Fields?> nullableFields(_$classes.Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nullable-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Fields?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.Fields?>($body['response']);
  }

  Future<_$classes.Fields?> asyncNullableFields(_$classes.Fields? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nullable-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$classes.Fields?>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.Fields?>($body['response']);
  }

  Future<_$classes.NamedFields> namedFields(_$classes.NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NamedFields>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NamedFields>($body['response']);
  }

  Future<_$classes.NamedFields> asyncNamedFields(
      _$classes.NamedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NamedFields>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NamedFields>($body['response']);
  }

  Future<_$classes.MixedFields> mixedFields(_$classes.MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/mixed-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.MixedFields>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.MixedFields>($body['response']);
  }

  Future<_$classes.MixedFields> asyncMixedFields(
      _$classes.MixedFields value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-mixed-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.MixedFields>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.MixedFields>($body['response']);
  }

  Future<_$classes.DefaultValues> defaultValues(
      _$classes.DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.DefaultValues>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.DefaultValues>($body['response']);
  }

  Future<_$classes.DefaultValues> asyncDefaultValues(
      _$classes.DefaultValues value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.DefaultValues>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.DefaultValues>($body['response']);
  }

  Future<_$classes.NestedClass> nestedClass(_$classes.NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/nested-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NestedClass>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NestedClass>($body['response']);
  }

  Future<_$classes.NestedClass> asyncNestedClass(
      _$classes.NestedClass value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-nested-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NestedClass>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NestedClass>($body['response']);
  }

  Future<_$classes.OnlyFromJson> onlyFromJson(
      _$classes.OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.OnlyFromJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyFromJson>($body['response']);
  }

  Future<_$classes.OnlyFromJson> asyncOnlyFromJson(
      _$classes.OnlyFromJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.OnlyFromJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyFromJson>($body['response']);
  }

  Future<_$classes.OnlyToJson> onlyToJson(_$classes.OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.OnlyToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyToJson>($body['response']);
  }

  Future<_$classes.OnlyToJson> asyncOnlyToJson(
      _$classes.OnlyToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.OnlyToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyToJson>($body['response']);
  }

  Future<_$classes.OnlyToJsonWithDefaults> onlyToJsonWithDefaults(
      _$classes.OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/only-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$classes.OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyToJsonWithDefaults>($body['response']);
  }

  Future<_$classes.OnlyToJsonWithDefaults> asyncOnlyToJsonWithDefaults(
      _$classes.OnlyToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-only-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$classes.OnlyToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.OnlyToJsonWithDefaults>($body['response']);
  }

  Future<_$classes.FromJsonAndToJson> fromAndToJson(
      _$classes.FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$classes.FromJsonAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.FromJsonAndToJson>($body['response']);
  }

  Future<_$classes.FromJsonAndToJson> asyncFromAndToJson(
      _$classes.FromJsonAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$classes.FromJsonAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.FromJsonAndToJson>($body['response']);
  }

  Future<_$classes.NonMapToJson> nonMapToJson(
      _$classes.NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NonMapToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapToJson>($body['response']);
  }

  Future<_$classes.NonMapToJson> asyncNonMapToJson(
      _$classes.NonMapToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<_$classes.NonMapToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapToJson>($body['response']);
  }

  Future<_$classes.NonMapToJsonWithDefaults> nonMapToJsonWithDefaults(
      _$classes.NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$classes.NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapToJsonWithDefaults>($body['response']);
  }

  Future<_$classes.NonMapToJsonWithDefaults> asyncNonMapToJsonWithDefaults(
      _$classes.NonMapToJsonWithDefaults value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-to-json-with-defaults'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$classes.NonMapToJsonWithDefaults>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapToJsonWithDefaults>($body['response']);
  }

  Future<_$classes.NonMapFromAndToJson> nonMapFromAndToJson(
      _$classes.NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/non-map-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$classes.NonMapFromAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapFromAndToJson>($body['response']);
  }

  Future<_$classes.NonMapFromAndToJson> asyncNonMapFromAndToJson(
      _$classes.NonMapFromAndToJson value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/async-non-map-from-and-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$classes.NonMapFromAndToJson>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.NonMapFromAndToJson>($body['response']);
  }

  Future<_$classes.FromJsonStatic> fromJsonStatic(
      _$classes.FromJsonStatic value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/classes/from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$classes.FromJsonStatic>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$classes.FromJsonStatic>($body['response']);
  }
}

/// Tests that collections (e.g. Lists/Maps) can be used as parameter and
/// return types.
class CelestFunctionsCollections {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<List<String>> simpleList(List<String> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'list': list}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<_$parameter_types.SimpleClass>> complexList(
      List<_$parameter_types.SimpleClass> list) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'list': list
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) =>
            Serializers.instance.deserialize<_$parameter_types.SimpleClass>(el))
        .toList();
  }

  Future<Map<String, String>> simpleMap(Map<String, String> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/simple-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'map': map}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<Map<String, dynamic>> dynamicMap(Map<String, dynamic> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/dynamic-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'map': map}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>);
  }

  Future<Map<String, Object>> objectMap(Map<String, Object> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/object-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'map': map}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          value!,
        ));
  }

  Future<Map<String, Object?>> objectNullableMap(
      Map<String, Object?> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/object-nullable-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'map': map}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>);
  }

  Future<Map<String, _$parameter_types.SimpleClass>> complexMap(
      Map<String, _$parameter_types.SimpleClass> map) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/collections/complex-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'map': map.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleClass>(value),
            ))
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          Serializers.instance
              .deserialize<_$parameter_types.SimpleClass>(value),
        ));
  }
}

/// Tests that some cycles are allowed, e.g. when there is at least one level
/// of indirection.
class CelestFunctionsCycles {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$cycles.Node> createTree() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/create-tree'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$cycles.Node>($body['response']);
  }

  Future<void> printTree(_$cycles.Node node) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/print-tree'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'node': Serializers.instance.serialize<_$cycles.Node>(node)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<_$cycles.Node> combineTrees(
    _$cycles.Node tree1, [
    _$cycles.Parent? tree2,
    _$cycles.Node? tree3,
    List<_$cycles.Node?> additionalChildren = const [],
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/combine-trees'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'tree1': Serializers.instance.serialize<_$cycles.Node>(tree1),
        r'tree2': Serializers.instance.serialize<_$cycles.Parent?>(tree2),
        r'tree3': Serializers.instance.serialize<_$cycles.Node?>(tree3),
        r'additionalChildren': additionalChildren
            .map((el) => Serializers.instance.serialize<_$cycles.Node?>(el))
            .toList(),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$cycles.Node>($body['response']);
  }

  /// Tests that self-referencing is allowed when there is a level
  /// of indirection, e.g. nullability, generics, or a wrapper.
  Future<_$cycles.SelfReferencing> selfReferencing(
      _$cycles.SelfReferencing selfReferencing) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/cycles/self-referencing'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'selfReferencing': Serializers.instance
            .serialize<_$cycles.SelfReferencing>(selfReferencing)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$cycles.SelfReferencing>($body['response']);
  }
}

class CelestFunctionsDemo {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case r'BadNameException':
        throw Serializers.instance
            .deserialize<_$demo.BadNameException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// Says hello to a [person].
  Future<String> sayHello({required _$demo.Person person}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/demo/say-hello'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'person': Serializers.instance.serialize<_$demo.Person>(person)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }
}

class CelestFunctionsExceptions {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case r'CustomException':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomException>($details);
      case r'CustomExceptionToFromJson':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomExceptionToFromJson>($details);
      case r'CustomError':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomError>($details);
      case r'CustomErrorToFromJson':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomErrorToFromJson>($details);
      case r'CustomErrorWithStackTrace':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomErrorWithStackTrace>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> throwsException(
      {required _$exceptions.SupportedExceptionType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'type': Serializers.instance
            .serialize<_$exceptions.SupportedExceptionType>(type)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsError(
      {required _$exceptions.SupportedErrorType type}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-error'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'type': Serializers.instance
            .serialize<_$exceptions.SupportedErrorType>(type)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomExceptionToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-exception-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomError() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomErrorToFromJson() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/exceptions/throws-custom-error-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCustomErrorWithStackTrace() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/exceptions/throws-custom-error-with-stack-trace'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

/// Tests that extension types are correctly handled by the analyzer.
class CelestFunctionsExtensionTypes {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$extension_types.StringX> string(_$extension_types.StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringX>(
          s,
          const TypeToken<_$extension_types.StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringX>(
      $body['response'],
      const TypeToken<_$extension_types.StringX>('StringX'),
    );
  }

  Future<_$extension_types.StringX> asyncOrString(
      _$extension_types.StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-or-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringX>(
          s,
          const TypeToken<_$extension_types.StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringX>(
      $body['response'],
      const TypeToken<_$extension_types.StringX>('StringX'),
    );
  }

  Future<_$extension_types.StringX> asyncString(
      _$extension_types.StringX s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/async-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringX>(
          s,
          const TypeToken<_$extension_types.StringX>('StringX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringX>(
      $body['response'],
      const TypeToken<_$extension_types.StringX>('StringX'),
    );
  }

  Future<_$extension_types.StringXImpl> stringImpl(
      _$extension_types.StringXImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringXImpl>(
          s,
          const TypeToken<_$extension_types.StringXImpl>('StringXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringXImpl>(
      $body['response'],
      const TypeToken<_$extension_types.StringXImpl>('StringXImpl'),
    );
  }

  Future<_$extension_types.StringXToFromJson> stringToFromJson(
      _$extension_types.StringXToFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's':
            Serializers.instance.serialize<_$extension_types.StringXToFromJson>(
          s,
          const TypeToken<_$extension_types.StringXToFromJson>(
              'StringXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXToFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.StringXToFromJson>('StringXToFromJson'),
    );
  }

  Future<_$extension_types.StringXToJson> stringToJson(
      _$extension_types.StringXToJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringXToJson>(
          s,
          const TypeToken<_$extension_types.StringXToJson>('StringXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringXToJson>(
      $body['response'],
      const TypeToken<_$extension_types.StringXToJson>('StringXToJson'),
    );
  }

  Future<_$extension_types.StringXToJsonImpl> stringToJsonImpl(
      _$extension_types.StringXToJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's':
            Serializers.instance.serialize<_$extension_types.StringXToJsonImpl>(
          s,
          const TypeToken<_$extension_types.StringXToJsonImpl>(
              'StringXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXToJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.StringXToJsonImpl>('StringXToJsonImpl'),
    );
  }

  Future<_$extension_types.StringXFromJson> stringFromJson(
      _$extension_types.StringXFromJson s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance.serialize<_$extension_types.StringXFromJson>(
          s,
          const TypeToken<_$extension_types.StringXFromJson>('StringXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.StringXFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.StringXFromJson>('StringXFromJson'),
    );
  }

  Future<_$extension_types.StringXFromJsonImpl> stringFromJsonImpl(
      _$extension_types.StringXFromJsonImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXFromJsonImpl>(
          s,
          const TypeToken<_$extension_types.StringXFromJsonImpl>(
              'StringXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXFromJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.StringXFromJsonImpl>(
          'StringXFromJsonImpl'),
    );
  }

  Future<_$extension_types.StringXFromJsonStatic> stringFromJsonStatic(
      _$extension_types.StringXFromJsonStatic s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXFromJsonStatic>(
          s,
          const TypeToken<_$extension_types.StringXFromJsonStatic>(
              'StringXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXFromJsonStatic>(
      $body['response'],
      const TypeToken<_$extension_types.StringXFromJsonStatic>(
          'StringXFromJsonStatic'),
    );
  }

  Future<_$extension_types.StringXPrivateField> stringPrivateField(
      _$extension_types.StringXPrivateField s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXPrivateField>(
          s,
          const TypeToken<_$extension_types.StringXPrivateField>(
              'StringXPrivateField'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXPrivateField>(
      $body['response'],
      const TypeToken<_$extension_types.StringXPrivateField>(
          'StringXPrivateField'),
    );
  }

  Future<_$extension_types.StringXPrivateFieldImpl> stringPrivateFieldImpl(
      _$extension_types.StringXPrivateFieldImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-field-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXPrivateFieldImpl>(
          s,
          const TypeToken<_$extension_types.StringXPrivateFieldImpl>(
              'StringXPrivateFieldImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXPrivateFieldImpl>(
      $body['response'],
      const TypeToken<_$extension_types.StringXPrivateFieldImpl>(
          'StringXPrivateFieldImpl'),
    );
  }

  Future<_$extension_types.StringXPrivateCtor> stringPrivateCtor(
      _$extension_types.StringXPrivateCtor s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXPrivateCtor>(
          s,
          const TypeToken<_$extension_types.StringXPrivateCtor>(
              'StringXPrivateCtor'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXPrivateCtor>(
      $body['response'],
      const TypeToken<_$extension_types.StringXPrivateCtor>(
          'StringXPrivateCtor'),
    );
  }

  Future<_$extension_types.StringXPrivateCtorImpl> stringPrivateCtorImpl(
      _$extension_types.StringXPrivateCtorImpl s) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/string-private-ctor-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r's': Serializers.instance
            .serialize<_$extension_types.StringXPrivateCtorImpl>(
          s,
          const TypeToken<_$extension_types.StringXPrivateCtorImpl>(
              'StringXPrivateCtorImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.StringXPrivateCtorImpl>(
      $body['response'],
      const TypeToken<_$extension_types.StringXPrivateCtorImpl>(
          'StringXPrivateCtorImpl'),
    );
  }

  Future<_$extension_types.Value> value(_$extension_types.Value v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'v': Serializers.instance.serialize<_$extension_types.Value>(v)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.Value>($body['response']);
  }

  Future<_$extension_types.ValueX> valuex(_$extension_types.ValueX v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/valuex'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<_$extension_types.ValueX>(
          v,
          const TypeToken<_$extension_types.ValueX>('ValueX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueX>(
      $body['response'],
      const TypeToken<_$extension_types.ValueX>('ValueX'),
    );
  }

  Future<_$extension_types.ValueXImpl> valueXImpl(
      _$extension_types.ValueXImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<_$extension_types.ValueXImpl>(
          v,
          const TypeToken<_$extension_types.ValueXImpl>('ValueXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueXImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXImpl>('ValueXImpl'),
    );
  }

  Future<_$extension_types.ValueXToFromJson> valueXToFromJson(
      _$extension_types.ValueXToFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v':
            Serializers.instance.serialize<_$extension_types.ValueXToFromJson>(
          v,
          const TypeToken<_$extension_types.ValueXToFromJson>(
              'ValueXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueXToFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXToFromJson>('ValueXToFromJson'),
    );
  }

  Future<_$extension_types.ValueXToJson> valueXToJson(
      _$extension_types.ValueXToJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<_$extension_types.ValueXToJson>(
          v,
          const TypeToken<_$extension_types.ValueXToJson>('ValueXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueXToJson>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXToJson>('ValueXToJson'),
    );
  }

  Future<_$extension_types.ValueXToJsonImpl> valueXToJsonImpl(
      _$extension_types.ValueXToJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v':
            Serializers.instance.serialize<_$extension_types.ValueXToJsonImpl>(
          v,
          const TypeToken<_$extension_types.ValueXToJsonImpl>(
              'ValueXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueXToJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXToJsonImpl>('ValueXToJsonImpl'),
    );
  }

  Future<_$extension_types.ValueXFromJson> valueXFromJson(
      _$extension_types.ValueXFromJson v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance.serialize<_$extension_types.ValueXFromJson>(
          v,
          const TypeToken<_$extension_types.ValueXFromJson>('ValueXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ValueXFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXFromJson>('ValueXFromJson'),
    );
  }

  Future<_$extension_types.ValueXFromJsonImpl> valueXFromJsonImpl(
      _$extension_types.ValueXFromJsonImpl v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance
            .serialize<_$extension_types.ValueXFromJsonImpl>(
          v,
          const TypeToken<_$extension_types.ValueXFromJsonImpl>(
              'ValueXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.ValueXFromJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXFromJsonImpl>(
          'ValueXFromJsonImpl'),
    );
  }

  Future<_$extension_types.ValueXFromJsonStatic> valueXFromJsonStatic(
      _$extension_types.ValueXFromJsonStatic v) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/value-x-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'v': Serializers.instance
            .serialize<_$extension_types.ValueXFromJsonStatic>(
          v,
          const TypeToken<_$extension_types.ValueXFromJsonStatic>(
              'ValueXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.ValueXFromJsonStatic>(
      $body['response'],
      const TypeToken<_$extension_types.ValueXFromJsonStatic>(
          'ValueXFromJsonStatic'),
    );
  }

  Future<_$extension_types.Color> color(_$extension_types.Color color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<_$extension_types.Color>(color)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.Color>($body['response']);
  }

  Future<_$extension_types.ColorX> colorx(
      _$extension_types.ColorX color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/colorx'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<_$extension_types.ColorX>(
          color,
          const TypeToken<_$extension_types.ColorX>('ColorX'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorX>(
      $body['response'],
      const TypeToken<_$extension_types.ColorX>('ColorX'),
    );
  }

  Future<_$extension_types.ColorXImpl> colorXImpl(
      _$extension_types.ColorXImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance.serialize<_$extension_types.ColorXImpl>(
          color,
          const TypeToken<_$extension_types.ColorXImpl>('ColorXImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorXImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXImpl>('ColorXImpl'),
    );
  }

  Future<_$extension_types.ColorXToFromJson> colorXToFromJson(
      _$extension_types.ColorXToFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color':
            Serializers.instance.serialize<_$extension_types.ColorXToFromJson>(
          color,
          const TypeToken<_$extension_types.ColorXToFromJson>(
              'ColorXToFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorXToFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXToFromJson>('ColorXToFromJson'),
    );
  }

  Future<_$extension_types.ColorXToJson> colorXToJson(
      _$extension_types.ColorXToJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color':
            Serializers.instance.serialize<_$extension_types.ColorXToJson>(
          color,
          const TypeToken<_$extension_types.ColorXToJson>('ColorXToJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorXToJson>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXToJson>('ColorXToJson'),
    );
  }

  Future<_$extension_types.ColorXToJsonImpl> colorXToJsonImpl(
      _$extension_types.ColorXToJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-to-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color':
            Serializers.instance.serialize<_$extension_types.ColorXToJsonImpl>(
          color,
          const TypeToken<_$extension_types.ColorXToJsonImpl>(
              'ColorXToJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorXToJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXToJsonImpl>('ColorXToJsonImpl'),
    );
  }

  Future<_$extension_types.ColorXFromJson> colorXFromJson(
      _$extension_types.ColorXFromJson color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color':
            Serializers.instance.serialize<_$extension_types.ColorXFromJson>(
          color,
          const TypeToken<_$extension_types.ColorXFromJson>('ColorXFromJson'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<_$extension_types.ColorXFromJson>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXFromJson>('ColorXFromJson'),
    );
  }

  Future<_$extension_types.ColorXFromJsonImpl> colorXFromJsonImpl(
      _$extension_types.ColorXFromJsonImpl color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-impl'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance
            .serialize<_$extension_types.ColorXFromJsonImpl>(
          color,
          const TypeToken<_$extension_types.ColorXFromJsonImpl>(
              'ColorXFromJsonImpl'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.ColorXFromJsonImpl>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXFromJsonImpl>(
          'ColorXFromJsonImpl'),
    );
  }

  Future<_$extension_types.ColorXFromJsonStatic> colorXFromJsonStatic(
      _$extension_types.ColorXFromJsonStatic color) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/color-x-from-json-static'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'color': Serializers.instance
            .serialize<_$extension_types.ColorXFromJsonStatic>(
          color,
          const TypeToken<_$extension_types.ColorXFromJsonStatic>(
              'ColorXFromJsonStatic'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$extension_types.ColorXFromJsonStatic>(
      $body['response'],
      const TypeToken<_$extension_types.ColorXFromJsonStatic>(
          'ColorXFromJsonStatic'),
    );
  }

  Future<JsonValue> jsonValue(JsonValue value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-value'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonValue>(
          value,
          const TypeToken<JsonValue>('JsonValue'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonValue>(
      $body['response'],
      const TypeToken<JsonValue>('JsonValue'),
    );
  }

  Future<JsonString> jsonString(JsonString value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-string'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonString>(
          value,
          const TypeToken<JsonString>('JsonString'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonString>(
      $body['response'],
      const TypeToken<JsonString>('JsonString'),
    );
  }

  Future<JsonNum> jsonNum(JsonNum value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-num'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonNum>(
          value,
          const TypeToken<JsonNum>('JsonNum'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonNum>(
      $body['response'],
      const TypeToken<JsonNum>('JsonNum'),
    );
  }

  Future<JsonInt> jsonInt(JsonInt value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-int'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonInt>(
          value,
          const TypeToken<JsonInt>('JsonInt'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonInt>(
      $body['response'],
      const TypeToken<JsonInt>('JsonInt'),
    );
  }

  Future<JsonDouble> jsonDouble(JsonDouble value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-double'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonDouble>(
          value,
          const TypeToken<JsonDouble>('JsonDouble'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonDouble>(
      $body['response'],
      const TypeToken<JsonDouble>('JsonDouble'),
    );
  }

  Future<JsonBool> jsonBool(JsonBool value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-bool'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonBool>(
          value,
          const TypeToken<JsonBool>('JsonBool'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonBool>(
      $body['response'],
      const TypeToken<JsonBool>('JsonBool'),
    );
  }

  Future<JsonList> jsonList(JsonList value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-list'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonList>(
          value,
          const TypeToken<JsonList>('JsonList'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonList>(
      $body['response'],
      const TypeToken<JsonList>('JsonList'),
    );
  }

  Future<JsonMap> jsonMap(JsonMap value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/extension-types/json-map'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance.serialize<JsonMap>(
          value,
          const TypeToken<JsonMap>('JsonMap'),
        )
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<JsonMap>(
      $body['response'],
      const TypeToken<JsonMap>('JsonMap'),
    );
  }
}

/// Tests that classes which wrap generic types are generated correctly when
/// those generic types follow the specifications of `json_serializable`, e.g.
/// having a `toJson` method with function parameters for mapping the
/// underlying types to JSON (Object Function(T) toJsonT).
class CelestFunctionsGenericWrappers {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$generic_wrappers.GenericWrappers> genericWrappers(
      _$generic_wrappers.GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$generic_wrappers.GenericWrappers>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$generic_wrappers.GenericWrappers>($body['response']);
  }

  Future<_$generic_wrappers.GenericWrappers> genericWrappersAsync(
      _$generic_wrappers.GenericWrappers value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrappers-async'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<_$generic_wrappers.GenericWrappers>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$generic_wrappers.GenericWrappers>($body['response']);
  }

  Future<_$generic_wrappers.GenericWrappers> genericWrapperParameters({
    required _$ilist.IList<String> listOfString,
    required _$ilist.IList<Uri> listOfUri,
    required _$ilist.IList<_$parameter_types.SimpleClass> listOfSimpleClass,
    required _$ilist.IList<_$ilist.IList<String>> listOfListOfString,
    required _$ilist.IList<_$ilist.IList<Uri>> listOfListOfUri,
    required _$ilist.IList<_$ilist.IList<_$parameter_types.SimpleClass>>
        listOfListOfSimpleClass,
    required _$imap.IMap<String, String> mapOfString,
    required _$imap.IMap<String, Uri> mapOfUri,
    required _$imap.IMap<String, _$parameter_types.SimpleClass>
        mapOfSimpleClass,
    required _$imap.IMap<String, _$ilist.IList<String>> mapOfListOfString,
    required _$imap.IMap<String, _$ilist.IList<Uri>> mapOfListOfUri,
    required _$imap.IMap<String, _$ilist.IList<_$parameter_types.SimpleClass>>
        mapOfListOfSimpleClass,
    required _$imap.IMap<String, _$imap.IMap<String, String>> mapOfMapOfString,
    required _$imap.IMap<String, _$imap.IMap<String, Uri>> mapOfMapOfUri,
    required _$imap
        .IMap<String, _$imap.IMap<String, _$parameter_types.SimpleClass>>
        mapOfMapOfSimpleClass,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/generic-wrappers/generic-wrapper-parameters'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'listOfString':
            Serializers.instance.serialize<_$ilist.IList<String>>(listOfString),
        r'listOfUri':
            Serializers.instance.serialize<_$ilist.IList<Uri>>(listOfUri),
        r'listOfSimpleClass': Serializers.instance
            .serialize<_$ilist.IList<_$parameter_types.SimpleClass>>(
                listOfSimpleClass),
        r'listOfListOfString': Serializers.instance
            .serialize<_$ilist.IList<_$ilist.IList<String>>>(
                listOfListOfString),
        r'listOfListOfUri': Serializers.instance
            .serialize<_$ilist.IList<_$ilist.IList<Uri>>>(listOfListOfUri),
        r'listOfListOfSimpleClass': Serializers.instance.serialize<
                _$ilist.IList<_$ilist.IList<_$parameter_types.SimpleClass>>>(
            listOfListOfSimpleClass),
        r'mapOfString': Serializers.instance
            .serialize<_$imap.IMap<String, String>>(mapOfString),
        r'mapOfUri':
            Serializers.instance.serialize<_$imap.IMap<String, Uri>>(mapOfUri),
        r'mapOfSimpleClass': Serializers.instance
            .serialize<_$imap.IMap<String, _$parameter_types.SimpleClass>>(
                mapOfSimpleClass),
        r'mapOfListOfString': Serializers.instance
            .serialize<_$imap.IMap<String, _$ilist.IList<String>>>(
                mapOfListOfString),
        r'mapOfListOfUri': Serializers.instance
            .serialize<_$imap.IMap<String, _$ilist.IList<Uri>>>(mapOfListOfUri),
        r'mapOfListOfSimpleClass': Serializers.instance.serialize<
                _$imap
                .IMap<String, _$ilist.IList<_$parameter_types.SimpleClass>>>(
            mapOfListOfSimpleClass),
        r'mapOfMapOfString': Serializers.instance
            .serialize<_$imap.IMap<String, _$imap.IMap<String, String>>>(
                mapOfMapOfString),
        r'mapOfMapOfUri': Serializers.instance
            .serialize<_$imap.IMap<String, _$imap.IMap<String, Uri>>>(
                mapOfMapOfUri),
        r'mapOfMapOfSimpleClass': Serializers.instance.serialize<
                _$imap.IMap<String,
                    _$imap.IMap<String, _$parameter_types.SimpleClass>>>(
            mapOfMapOfSimpleClass),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$generic_wrappers.GenericWrappers>($body['response']);
  }
}

/// Tests that metadata associated with functions and parameters are correctly
/// parsed and transferred to the generated client.
class CelestFunctionsMetadata {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  /// A function that has doc comments.
  ///
  /// This is a doc comment.
  ///
  /// # This is an H1
  /// ## This is an H2
  /// ### This is an H3
  /// * This is a list item
  ///
  /// This is an example:
  ///
  /// ```dart
  /// void hasDocComments() {}
  /// ```
  Future<void> hasDocComments() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-doc-comments'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  @deprecated
  Future<void> hasDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-deprecated-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  @Deprecated('Do not use this function.')
  Future<void> hasConstructedDeprecatedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-constructed-deprecated-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasNamedConstructedAnnotation() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-named-constructed-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasLiteralsAnnotation(
    String value, {
    required String named,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-literals-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasExportableAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasExportableConstructedAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-exportable-constructed-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> hasNotExportableAnnotation(
    String value, {
    String named = 'named',
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/has-not-exportable-annotation'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'named': named,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValues([
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValues([
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-positional-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValues({
    String value = 'value',
    int intValue = 1,
    double doubleValue = 1.0,
    bool boolValue = true,
    List<String> list = const ['list'],
    Map<String, String> map = const {'map': 'map'},
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValues({
    String? value = 'value',
    int? intValue = 1,
    double? doubleValue = 1.0,
    bool? boolValue = true,
    List<String>? list = const ['list'],
    Map<String, String>? map = const {'map': 'map'},
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-values'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'intValue': intValue,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'list': list,
        r'map': map,
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValueVars([
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValueVars([
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValueVars({
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValueVars({
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/nullable-named-default-value-vars'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> positionalDefaultValueVarsPrivate([
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/positional-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullablePositionalDefaultValueVarsPrivate([
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-positional-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> namedDefaultValueVarsPrivate({
    int value = 42,
    double doubleValue = 42.0,
    bool boolValue = true,
    String stringValue = 'default',
    List<String> listValue = const ['default'],
    Map<String, String> mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    }) recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable exportable = const _$metadata.Exportable(),
    _$metadata.Serializable serializable =
        const _$metadata.Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/metadata/named-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> nullableNamedDefaultValueVarsPrivate({
    int? value = 42,
    double? doubleValue = 42.0,
    bool? boolValue = true,
    String? stringValue = 'default',
    List<String>? listValue = const ['default'],
    Map<String, String>? mapValue = const {'default': 'default'},
    _$metadata.LiteralEnum? enumValue = _$metadata.LiteralEnum.a,
    ({
      String a,
      String b,
      String c
    })? recordValue = const (a: 'a', b: 'b', c: 'c'),
    _$metadata.Exportable? exportable = const _$metadata.Exportable(),
    _$metadata.Serializable? serializable =
        const _$metadata.Serializable.forType('String'),
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/metadata/nullable-named-default-value-vars-private'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': value,
        r'doubleValue': doubleValue,
        r'boolValue': boolValue,
        r'stringValue': stringValue,
        r'listValue': listValue,
        r'mapValue': mapValue,
        r'enumValue':
            Serializers.instance.serialize<_$metadata.LiteralEnum?>(enumValue),
        r'recordValue': Serializers.instance
            .serialize<({String a, String b, String c})?>(recordValue),
        r'exportable':
            Serializers.instance.serialize<_$metadata.Exportable?>(exportable),
        r'serializable': Serializers.instance
            .serialize<_$metadata.Serializable?>(serializable),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

/// Tests that types can be recursively overriden in the serialization protocol
/// using extension types.
class CelestFunctionsOverrides {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case r'CustomException':
        throw Serializers.instance
            .deserialize<_$_common.CustomException>($details);
      case r'CommonException':
        throw Serializers.instance
            .deserialize<_$_common.CommonException>($details);
      case r'OverriddenException':
        throw Serializers.instance
            .deserialize<_$overrides.OverriddenException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$_common.NestedParent> commonNestedParent(
      _$_common.NestedParent parent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/common-nested-parent'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'parent':
            Serializers.instance.serialize<_$_common.NestedParent>(parent)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$_common.NestedParent>($body['response']);
  }

  Future<_$_common.NestedChild> commonNestedChild(
      _$_common.NestedChild child) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/common-nested-child'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'child': Serializers.instance.serialize<_$_common.NestedChild>(child)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$_common.NestedChild>($body['response']);
  }

  Future<_$overrides.NestedGrandparent> nestedGrandparent(
      _$overrides.NestedGrandparent grandparent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-grandparent'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'grandparent': Serializers.instance
            .serialize<_$overrides.NestedGrandparent>(grandparent)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$overrides.NestedGrandparent>($body['response']);
  }

  Future<_$overrides.NestedParent> nestedParent(
      _$overrides.NestedParent parent) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-parent'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'parent':
            Serializers.instance.serialize<_$overrides.NestedParent>(parent)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$overrides.NestedParent>($body['response']);
  }

  Future<_$overrides.NestedChild> nestedChild(
      _$overrides.NestedChild child) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/nested-child'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'child': Serializers.instance.serialize<_$overrides.NestedChild>(child)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$overrides.NestedChild>($body['response']);
  }

  Future<void> callsThrowsCommonOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/overrides/calls-throws-common-overridden-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsCommonOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/throws-common-overridden-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> throwsOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/throws-overridden-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> callsThrowsOverriddenException() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/overrides/calls-throws-overridden-exception'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsParameterTypes {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> simple(
    String aString,
    int anInt,
    double aDouble,
    bool aBool,
    _$parameter_types.MyEnum anEnum,
    Null aNull,
    BigInt aBigInt,
    DateTime aDateTime,
    Duration aDuration,
    RegExp aRegExp,
    StackTrace aStackTrace,
    Uri aUri,
    UriData aUriData,
    _$typed_data.Uint8List aUint8List,
    Iterable<String> anIterableOfString,
    Iterable<_$typed_data.Uint8List> anIterableOfUint8List,
    List<String> aListOfString,
    List<int> aListOfInt,
    List<double> aListOfDouble,
    List<bool> aListOfBool,
    List<_$parameter_types.MyEnum> aListOfEnum,
    List<Null> aListOfNull,
    List<BigInt> aListOfBigInt,
    List<DateTime> aListOfDateTime,
    List<Duration> aListOfDuration,
    List<RegExp> aListOfRegExp,
    List<StackTrace> aListOfStackTrace,
    List<Uri> aListOfUri,
    List<UriData> aListOfUriData,
    List<_$typed_data.Uint8List> aListOfUint8List,
    Map<String, String> aMapOfString,
    Map<String, int> aMapOfInt,
    Map<String, double> aMapOfDouble,
    Map<String, bool> aMapOfBool,
    Map<String, _$parameter_types.MyEnum> aMapOfEnum,
    Map<String, Null> aMapOfNull,
    Map<String, BigInt> aMapOfBigInt,
    Map<String, DateTime> aMapOfDateTime,
    Map<String, Duration> aMapOfDuration,
    Map<String, RegExp> aMapOfRegExp,
    Map<String, StackTrace> aMapOfStackTrace,
    Map<String, Uri> aMapOfUri,
    Map<String, UriData> aMapOfUriData,
    Map<String, _$typed_data.Uint8List> aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum':
            Serializers.instance.serialize<_$parameter_types.MyEnum>(anEnum),
        r'aNull': aNull,
        r'aBigInt': Serializers.instance.serialize<BigInt>(aBigInt),
        r'aDateTime': Serializers.instance.serialize<DateTime>(aDateTime),
        r'aDuration': Serializers.instance.serialize<Duration>(aDuration),
        r'aRegExp': Serializers.instance.serialize<RegExp>(aRegExp),
        r'aStackTrace': Serializers.instance.serialize<StackTrace>(aStackTrace),
        r'aUri': Serializers.instance.serialize<Uri>(aUri),
        r'aUriData': Serializers.instance.serialize<UriData>(aUriData),
        r'aUint8List':
            Serializers.instance.serialize<_$typed_data.Uint8List>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            .map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            .map((el) =>
                Serializers.instance.serialize<_$parameter_types.MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            .map((el) => Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            .map((el) => Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            .map((el) => Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            .map((el) => Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            .map((el) => Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            .map((el) => Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            .map((el) => Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            .map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$parameter_types.MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$typed_data.Uint8List>(value),
            )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> simpleOptional(
    String? aString,
    int? anInt,
    double? aDouble,
    bool? aBool,
    _$parameter_types.MyEnum? anEnum,
    Null aNull,
    BigInt? aBigInt,
    DateTime? aDateTime,
    Duration? aDuration,
    RegExp? aRegExp,
    StackTrace? aStackTrace,
    Uri? aUri,
    UriData? aUriData,
    _$typed_data.Uint8List? aUint8List,
    Iterable<String>? anIterableOfString,
    Iterable<_$typed_data.Uint8List>? anIterableOfUint8List,
    List<String>? aListOfString,
    List<int>? aListOfInt,
    List<double>? aListOfDouble,
    List<bool>? aListOfBool,
    List<_$parameter_types.MyEnum>? aListOfEnum,
    List<Null>? aListOfNull,
    List<BigInt>? aListOfBigInt,
    List<DateTime>? aListOfDateTime,
    List<Duration>? aListOfDuration,
    List<RegExp>? aListOfRegExp,
    List<StackTrace>? aListOfStackTrace,
    List<Uri>? aListOfUri,
    List<UriData>? aListOfUriData,
    List<_$typed_data.Uint8List>? aListOfUint8List,
    Map<String, String>? aMapOfString,
    Map<String, int>? aMapOfInt,
    Map<String, double>? aMapOfDouble,
    Map<String, bool>? aMapOfBool,
    Map<String, _$parameter_types.MyEnum>? aMapOfEnum,
    Map<String, Null>? aMapOfNull,
    Map<String, BigInt>? aMapOfBigInt,
    Map<String, DateTime>? aMapOfDateTime,
    Map<String, Duration>? aMapOfDuration,
    Map<String, RegExp>? aMapOfRegExp,
    Map<String, StackTrace>? aMapOfStackTrace,
    Map<String, Uri>? aMapOfUri,
    Map<String, UriData>? aMapOfUriData,
    Map<String, _$typed_data.Uint8List>? aMapOfUint8List,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/simple-optional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aString': aString,
        r'anInt': anInt,
        r'aDouble': aDouble,
        r'aBool': aBool,
        r'anEnum':
            Serializers.instance.serialize<_$parameter_types.MyEnum?>(anEnum),
        r'aNull': aNull,
        r'aBigInt': Serializers.instance.serialize<BigInt?>(aBigInt),
        r'aDateTime': Serializers.instance.serialize<DateTime?>(aDateTime),
        r'aDuration': Serializers.instance.serialize<Duration?>(aDuration),
        r'aRegExp': Serializers.instance.serialize<RegExp?>(aRegExp),
        r'aStackTrace':
            Serializers.instance.serialize<StackTrace?>(aStackTrace),
        r'aUri': Serializers.instance.serialize<Uri?>(aUri),
        r'aUriData': Serializers.instance.serialize<UriData?>(aUriData),
        r'aUint8List':
            Serializers.instance.serialize<_$typed_data.Uint8List?>(aUint8List),
        r'anIterableOfString': anIterableOfString,
        r'anIterableOfUint8List': anIterableOfUint8List
            ?.map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aListOfString': aListOfString,
        r'aListOfInt': aListOfInt,
        r'aListOfDouble': aListOfDouble,
        r'aListOfBool': aListOfBool,
        r'aListOfEnum': aListOfEnum
            ?.map((el) =>
                Serializers.instance.serialize<_$parameter_types.MyEnum>(el))
            .toList(),
        r'aListOfNull': aListOfNull,
        r'aListOfBigInt': aListOfBigInt
            ?.map((el) => Serializers.instance.serialize<BigInt>(el))
            .toList(),
        r'aListOfDateTime': aListOfDateTime
            ?.map((el) => Serializers.instance.serialize<DateTime>(el))
            .toList(),
        r'aListOfDuration': aListOfDuration
            ?.map((el) => Serializers.instance.serialize<Duration>(el))
            .toList(),
        r'aListOfRegExp': aListOfRegExp
            ?.map((el) => Serializers.instance.serialize<RegExp>(el))
            .toList(),
        r'aListOfStackTrace': aListOfStackTrace
            ?.map((el) => Serializers.instance.serialize<StackTrace>(el))
            .toList(),
        r'aListOfUri': aListOfUri
            ?.map((el) => Serializers.instance.serialize<Uri>(el))
            .toList(),
        r'aListOfUriData': aListOfUriData
            ?.map((el) => Serializers.instance.serialize<UriData>(el))
            .toList(),
        r'aListOfUint8List': aListOfUint8List
            ?.map((el) =>
                Serializers.instance.serialize<_$typed_data.Uint8List>(el))
            .toList(),
        r'aMapOfString': aMapOfString,
        r'aMapOfInt': aMapOfInt,
        r'aMapOfDouble': aMapOfDouble,
        r'aMapOfBool': aMapOfBool,
        r'aMapOfEnum': aMapOfEnum?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$parameter_types.MyEnum>(value),
            )),
        r'aMapOfNull': aMapOfNull,
        r'aMapOfBigInt': aMapOfBigInt?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<BigInt>(value),
            )),
        r'aMapOfDateTime': aMapOfDateTime?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<DateTime>(value),
            )),
        r'aMapOfDuration': aMapOfDuration?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Duration>(value),
            )),
        r'aMapOfRegExp': aMapOfRegExp?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<RegExp>(value),
            )),
        r'aMapOfStackTrace': aMapOfStackTrace?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<StackTrace>(value),
            )),
        r'aMapOfUri': aMapOfUri?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<Uri>(value),
            )),
        r'aMapOfUriData': aMapOfUriData?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<UriData>(value),
            )),
        r'aMapOfUint8List': aMapOfUint8List?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance.serialize<_$typed_data.Uint8List>(value),
            )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> complex(
    _$parameter_types.SimpleStruct aSimpleStruct,
    _$parameter_types.ComplexStruct aComplexStruct,
    _$parameter_types.SimpleClass aSimpleClass,
    _$parameter_types.ComplexClass aComplexClass,
    _$parameter_types.SimpleStruct? aNullableSimpleStruct,
    _$parameter_types.ComplexStruct? aNullableComplexStruct,
    _$parameter_types.SimpleClass? aNullableSimpleClass,
    _$parameter_types.ComplexClass? aNullableComplexClass,
    Iterable<_$parameter_types.SimpleStruct> anIterableOfSimpleStruct,
    Iterable<_$parameter_types.ComplexStruct> anIterableOfComplexStruct,
    Iterable<_$parameter_types.SimpleClass> anIterableOfSimpleClass,
    Iterable<_$parameter_types.ComplexClass> anIterableOfComplexClass,
    Iterable<_$parameter_types.SimpleStruct>? aNullableIterableOfSimpleStruct,
    Iterable<_$parameter_types.ComplexStruct>? aNullableIterableOfComplexStruct,
    Iterable<_$parameter_types.SimpleClass>? aNullableIterableOfSimpleClass,
    Iterable<_$parameter_types.ComplexClass>? aNullableIterableOfComplexClass,
    Iterable<_$parameter_types.SimpleStruct?> anIterableOfNullableSimpleStruct,
    Iterable<_$parameter_types.ComplexStruct?>
        anIterableOfNullableComplexStruct,
    Iterable<_$parameter_types.SimpleClass?> anIterableOfNullableSimpleClass,
    Iterable<_$parameter_types.ComplexClass?> anIterableOfNullableComplexClass,
    List<_$parameter_types.SimpleStruct> aListOfSimpleStruct,
    List<_$parameter_types.ComplexStruct> aListOfComplexStruct,
    List<_$parameter_types.SimpleClass> aListOfSimpleClass,
    List<_$parameter_types.ComplexClass> aListOfComplexClass,
    List<_$parameter_types.SimpleStruct>? aNullableListOfSimpleStruct,
    List<_$parameter_types.ComplexStruct>? aNullableListOfComplexStruct,
    List<_$parameter_types.SimpleClass>? aNullableListOfSimpleClass,
    List<_$parameter_types.ComplexClass>? aNullableListOfComplexClass,
    List<_$parameter_types.SimpleStruct?> aListOfNullableSimpleStruct,
    List<_$parameter_types.ComplexStruct?> aListOfNullableComplexStruct,
    List<_$parameter_types.SimpleClass?> aListOfNullableSimpleClass,
    List<_$parameter_types.ComplexClass?> aListOfNullableComplexClass,
    Map<String, _$parameter_types.SimpleStruct> aMapOfSimpleStruct,
    Map<String, _$parameter_types.ComplexStruct> aMapOfComplexStruct,
    Map<String, _$parameter_types.SimpleClass> aMapOfSimpleClass,
    Map<String, _$parameter_types.ComplexClass> aMapOfComplexClass,
    Map<String, _$parameter_types.SimpleStruct>? aNullableMapOfSimpleStruct,
    Map<String, _$parameter_types.ComplexStruct>? aNullableMapOfComplexStruct,
    Map<String, _$parameter_types.SimpleClass>? aNullableMapOfSimpleClass,
    Map<String, _$parameter_types.ComplexClass>? aNullableMapOfComplexClass,
    Map<String, _$parameter_types.SimpleStruct?> aMapOfNullableSimpleStruct,
    Map<String, _$parameter_types.ComplexStruct?> aMapOfNullableComplexStruct,
    Map<String, _$parameter_types.SimpleClass?> aMapOfNullableSimpleClass,
    Map<String, _$parameter_types.ComplexClass?> aMapOfNullableComplexClass,
    Map<String, _$parameter_types.SimpleStruct?>?
        aNullableMapOfNullableSimpleStruct,
    Map<String, _$parameter_types.ComplexStruct?>?
        aNullableMapOfNullableComplexStruct,
    Map<String, _$parameter_types.SimpleClass?>?
        aNullableMapOfNullableSimpleClass,
    Map<String, _$parameter_types.ComplexClass?>?
        aNullableMapOfNullableComplexClass,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameter-types/complex'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'aSimpleStruct': Serializers.instance
            .serialize<_$parameter_types.SimpleStruct>(aSimpleStruct),
        r'aComplexStruct': Serializers.instance
            .serialize<_$parameter_types.ComplexStruct>(aComplexStruct),
        r'aSimpleClass': Serializers.instance
            .serialize<_$parameter_types.SimpleClass>(aSimpleClass),
        r'aComplexClass': Serializers.instance
            .serialize<_$parameter_types.ComplexClass>(aComplexClass),
        r'aNullableSimpleStruct': Serializers.instance
            .serialize<_$parameter_types.SimpleStruct?>(aNullableSimpleStruct),
        r'aNullableComplexStruct': Serializers.instance
            .serialize<_$parameter_types.ComplexStruct?>(
                aNullableComplexStruct),
        r'aNullableSimpleClass': Serializers.instance
            .serialize<_$parameter_types.SimpleClass?>(aNullableSimpleClass),
        r'aNullableComplexClass': Serializers.instance
            .serialize<_$parameter_types.ComplexClass?>(aNullableComplexClass),
        r'anIterableOfSimpleStruct': anIterableOfSimpleStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct>(el))
            .toList(),
        r'anIterableOfComplexStruct': anIterableOfComplexStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct>(el))
            .toList(),
        r'anIterableOfSimpleClass': anIterableOfSimpleClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass>(el))
            .toList(),
        r'anIterableOfComplexClass': anIterableOfComplexClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass>(el))
            .toList(),
        r'aNullableIterableOfSimpleStruct': aNullableIterableOfSimpleStruct
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct>(el))
            .toList(),
        r'aNullableIterableOfComplexStruct': aNullableIterableOfComplexStruct
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct>(el))
            .toList(),
        r'aNullableIterableOfSimpleClass': aNullableIterableOfSimpleClass
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass>(el))
            .toList(),
        r'aNullableIterableOfComplexClass': aNullableIterableOfComplexClass
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass>(el))
            .toList(),
        r'anIterableOfNullableSimpleStruct': anIterableOfNullableSimpleStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct?>(el))
            .toList(),
        r'anIterableOfNullableComplexStruct': anIterableOfNullableComplexStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct?>(el))
            .toList(),
        r'anIterableOfNullableSimpleClass': anIterableOfNullableSimpleClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass?>(el))
            .toList(),
        r'anIterableOfNullableComplexClass': anIterableOfNullableComplexClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass?>(el))
            .toList(),
        r'aListOfSimpleStruct': aListOfSimpleStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct>(el))
            .toList(),
        r'aListOfComplexStruct': aListOfComplexStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct>(el))
            .toList(),
        r'aListOfSimpleClass': aListOfSimpleClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass>(el))
            .toList(),
        r'aListOfComplexClass': aListOfComplexClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass>(el))
            .toList(),
        r'aNullableListOfSimpleStruct': aNullableListOfSimpleStruct
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct>(el))
            .toList(),
        r'aNullableListOfComplexStruct': aNullableListOfComplexStruct
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct>(el))
            .toList(),
        r'aNullableListOfSimpleClass': aNullableListOfSimpleClass
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass>(el))
            .toList(),
        r'aNullableListOfComplexClass': aNullableListOfComplexClass
            ?.map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass>(el))
            .toList(),
        r'aListOfNullableSimpleStruct': aListOfNullableSimpleStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleStruct?>(el))
            .toList(),
        r'aListOfNullableComplexStruct': aListOfNullableComplexStruct
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexStruct?>(el))
            .toList(),
        r'aListOfNullableSimpleClass': aListOfNullableSimpleClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.SimpleClass?>(el))
            .toList(),
        r'aListOfNullableComplexClass': aListOfNullableComplexClass
            .map((el) => Serializers.instance
                .serialize<_$parameter_types.ComplexClass?>(el))
            .toList(),
        r'aMapOfSimpleStruct': aMapOfSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleStruct>(value),
            )),
        r'aMapOfComplexStruct': aMapOfComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexStruct>(value),
            )),
        r'aMapOfSimpleClass': aMapOfSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleClass>(value),
            )),
        r'aMapOfComplexClass': aMapOfComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexClass>(value),
            )),
        r'aNullableMapOfSimpleStruct': aNullableMapOfSimpleStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleStruct>(value),
            )),
        r'aNullableMapOfComplexStruct': aNullableMapOfComplexStruct?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexStruct>(value),
            )),
        r'aNullableMapOfSimpleClass': aNullableMapOfSimpleClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleClass>(value),
            )),
        r'aNullableMapOfComplexClass': aNullableMapOfComplexClass?.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexClass>(value),
            )),
        r'aMapOfNullableSimpleStruct': aMapOfNullableSimpleStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleStruct?>(value),
            )),
        r'aMapOfNullableComplexStruct': aMapOfNullableComplexStruct.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexStruct?>(value),
            )),
        r'aMapOfNullableSimpleClass': aMapOfNullableSimpleClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.SimpleClass?>(value),
            )),
        r'aMapOfNullableComplexClass': aMapOfNullableComplexClass.map((
          key,
          value,
        ) =>
            MapEntry(
              key,
              Serializers.instance
                  .serialize<_$parameter_types.ComplexClass?>(value),
            )),
        r'aNullableMapOfNullableSimpleStruct':
            aNullableMapOfNullableSimpleStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance
                      .serialize<_$parameter_types.SimpleStruct?>(value),
                )),
        r'aNullableMapOfNullableComplexStruct':
            aNullableMapOfNullableComplexStruct?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance
                      .serialize<_$parameter_types.ComplexStruct?>(value),
                )),
        r'aNullableMapOfNullableSimpleClass':
            aNullableMapOfNullableSimpleClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance
                      .serialize<_$parameter_types.SimpleClass?>(value),
                )),
        r'aNullableMapOfNullableComplexClass':
            aNullableMapOfNullableComplexClass?.map((
          key,
          value,
        ) =>
                MapEntry(
                  key,
                  Serializers.instance
                      .serialize<_$parameter_types.ComplexClass?>(value),
                )),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

class CelestFunctionsParameters {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> optionalPositional([
    String? optionalString,
    int? optionalInt,
  ]) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-positional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'optionalString': optionalString,
        r'optionalInt': optionalInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> optionalNamed({
    String? namedString,
    int? namedInt,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/optional-named'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'namedString': namedString,
        r'namedInt': namedInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> requiredPositional(
    String requiredString,
    int requiredInt,
  ) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-positional'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<void> requiredNamed({
    required String requiredString,
    required int requiredInt,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/parameters/required-named'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'requiredString': requiredString,
        r'requiredInt': requiredInt,
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }
}

/// Tests that records with and without aliases are serializable and
/// deserializable.
class CelestFunctionsRecords {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<({String anotherField, String field})> nonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/non-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<({String anotherField, String field})>($body['response']);
  }

  Future<({String anotherField, String field})> asyncNonAliasedNamedFields(
      {required ({String anotherField, String field}) value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-non-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value': Serializers.instance
            .serialize<({String anotherField, String field})>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<({String anotherField, String field})>($body['response']);
  }

  Future<_$records.NamedFieldsRecord> aliasedNamedFields(
      {required _$records.NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$records.NamedFieldsRecord>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.NamedFieldsRecord>($body['response']);
  }

  Future<_$records.NamedFieldsRecord> asyncAliasedNamedFields(
      {required _$records.NamedFieldsRecord value}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-aliased-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$records.NamedFieldsRecord>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.NamedFieldsRecord>($body['response']);
  }

  Future<
      ({
        _$records.NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> namedFields({
    required ({String anotherField, String field}) nonAliased,
    required _$records.NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'nonAliased': Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased': Serializers.instance
            .serialize<_$records.NamedFieldsRecord>(aliased),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          _$records.NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body['response']);
  }

  Future<
      ({
        _$records.NamedFieldsRecord aliased,
        ({String anotherField, String field}) nonAliased
      })> asyncNamedFields({
    required ({String anotherField, String field}) nonAliased,
    required _$records.NamedFieldsRecord aliased,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-named-fields'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'nonAliased': Serializers.instance
            .serialize<({String anotherField, String field})>(nonAliased),
        r'aliased': Serializers.instance
            .serialize<_$records.NamedFieldsRecord>(aliased),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        ({
          _$records.NamedFieldsRecord aliased,
          ({String anotherField, String field}) nonAliased
        })>($body['response']);
  }

  Future<_$records.Nested> nested(_$records.Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$records.Nested>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.Nested>($body['response']);
  }

  Future<_$records.Nested> asyncNested(_$records.Nested value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode(
          {r'value': Serializers.instance.serialize<_$records.Nested>(value)}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.Nested>($body['response']);
  }

  Future<_$records.NullableNested?> nullableNested(
      _$records.NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/nullable-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$records.NullableNested?>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.NullableNested?>($body['response']);
  }

  Future<_$records.NullableNested?> asyncNullableNested(
      _$records.NullableNested? value) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/records/async-nullable-nested'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'value':
            Serializers.instance.serialize<_$records.NullableNested?>(value)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$records.NullableNested?>($body['response']);
  }
}

/// Validates all permutations of return types.
class CelestFunctionsReturnTypes {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<void> asyncVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> asyncStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> asyncIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> asyncDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> asyncBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> asyncIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> asyncListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> asyncMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<_$parameter_types.SimpleStruct> asyncStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct>($body['response']);
  }

  Future<_$parameter_types.SimpleStruct?> asyncStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct?>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct> asyncComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct?>
      asyncComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-complex-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct?>($body['response']);
  }

  Future<_$parameter_types.ComplexClass> asyncComplexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-complex-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexClass>($body['response']);
  }

  Future<_$parameter_types.SimpleClass?> asyncClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleClass?>($body['response']);
  }

  Future<void> asyncOrVoidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> asyncOrStringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> asyncOrIntReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> asyncOrDoubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> asyncOrBoolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> asyncOrIterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> asyncOrListReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> asyncOrMapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<_$parameter_types.SimpleStruct> asyncOrStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct> asyncOrComplexStructReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-complex-struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct>($body['response']);
  }

  Future<void> asyncOrVoidReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-void-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String?> asyncOrStringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-string-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String?);
  }

  Future<int?> asyncOrIntReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-int-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toInt();
  }

  Future<double?> asyncOrDoubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-double-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toDouble();
  }

  Future<bool?> asyncOrBoolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-bool-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool?);
  }

  Future<Iterable<String>?> asyncOrIterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-iterable-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<List<String>?> asyncOrListReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-list-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>?> asyncOrMapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-map-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<_$parameter_types.SimpleStruct?> asyncOrStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/async-or-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct?>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct?>
      asyncOrComplexStructReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct?>($body['response']);
  }

  Future<_$parameter_types.SimpleClass?>
      asyncOrSimpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-simple-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleClass?>($body['response']);
  }

  Future<_$parameter_types.ComplexClass?>
      asyncOrComplexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/return-types/async-or-complex-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexClass?>($body['response']);
  }

  Future<void> voidReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/void-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return;
  }

  Future<String> stringReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String);
  }

  Future<int> intReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toInt();
  }

  Future<double> doubleReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<bool> boolReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool);
  }

  Future<Iterable<String>> iterableReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<List<String>> listReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>> mapReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>).map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<_$parameter_types.SimpleStruct> structReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct> complexReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct>($body['response']);
  }

  Future<_$parameter_types.SimpleClass> simpleClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleClass>($body['response']);
  }

  Future<_$parameter_types.ComplexClass> complexClassReturn() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexClass>($body['response']);
  }

  Future<String?> stringReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/string-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as String?);
  }

  Future<int?> intReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/int-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toInt();
  }

  Future<double?> doubleReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/double-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num?)?.toDouble();
  }

  Future<bool?> boolReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/bool-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as bool?);
  }

  Future<Iterable<String>?> iterableReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/iterable-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<List<String>?> listReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/list-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>?)
        ?.map((el) => (el as String))
        .toList();
  }

  Future<Map<String, String>?> mapReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/map-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?)?.map((
      key,
      value,
    ) =>
        MapEntry(
          key,
          (value as String),
        ));
  }

  Future<_$parameter_types.SimpleStruct?> structReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/struct-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleStruct?>($body['response']);
  }

  Future<_$parameter_types.ComplexStruct?> complexReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexStruct?>($body['response']);
  }

  Future<_$parameter_types.SimpleClass?> simpleClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/simple-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.SimpleClass?>($body['response']);
  }

  Future<_$parameter_types.ComplexClass?> complexClassReturnNullable() async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/return-types/complex-class-return-nullable'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$parameter_types.ComplexClass?>($body['response']);
  }
}

class CelestFunctionsSealedClasses {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case r'CustomException':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomException>($details);
      case r'CustomExceptionToFromJson':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomExceptionToFromJson>($details);
      case r'CustomError':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomError>($details);
      case r'CustomErrorToFromJson':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomErrorToFromJson>($details);
      case r'CustomErrorWithStackTrace':
        throw Serializers.instance
            .deserialize<_$exceptions.CustomErrorWithStackTrace>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<double> area(_$sealed_classes.Shape shape) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/area'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shape': Serializers.instance.serialize<_$sealed_classes.Shape>(shape)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as num).toDouble();
  }

  Future<List<_$sealed_classes.Shape>> sealedClass(
      {required List<_$sealed_classes.Shape> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) =>
            Serializers.instance.deserialize<_$sealed_classes.Shape>(el))
        .toList();
  }

  Future<_$sealed_classes.Rectangle> rectangle(
      _$sealed_classes.Rectangle rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/rectangle'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'rectangle': Serializers.instance
            .serialize<_$sealed_classes.Rectangle>(rectangle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.Rectangle>($body['response']);
  }

  Future<_$sealed_classes.Circle> circle(_$sealed_classes.Circle circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/circle'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'circle':
            Serializers.instance.serialize<_$sealed_classes.Circle>(circle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.Circle>($body['response']);
  }

  Future<List<_$sealed_classes.ShapeWithInheritedCustomJson>>
      sealedClassWithInheritedCustomJson(
          {required List<_$sealed_classes.ShapeWithInheritedCustomJson>
              shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-inherited-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance
                .serialize<_$sealed_classes.ShapeWithInheritedCustomJson>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance
            .deserialize<_$sealed_classes.ShapeWithInheritedCustomJson>(el))
        .toList();
  }

  Future<List<_$sealed_classes.ShapeWithCustomJson>> sealedClassWithCustomJson(
      {required List<_$sealed_classes.ShapeWithCustomJson> shapes}) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/sealed-class-with-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) => Serializers.instance
                .serialize<_$sealed_classes.ShapeWithCustomJson>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance
            .deserialize<_$sealed_classes.ShapeWithCustomJson>(el))
        .toList();
  }

  Future<List<_$sealed_classes.ShapeWithOverriddenCustomJson>>
      sealedClassWithOverriddenCustomJson({
    required _$sealed_classes.CircleWithOverriddenCustomJson circle,
    required _$sealed_classes.RectangleWithOverriddenCustomJson rectangle,
    required List<_$sealed_classes.ShapeWithOverriddenCustomJson> other,
  }) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/sealed-class-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'circle': Serializers.instance
            .serialize<_$sealed_classes.CircleWithOverriddenCustomJson>(circle),
        r'rectangle': Serializers.instance
            .serialize<_$sealed_classes.RectangleWithOverriddenCustomJson>(
                rectangle),
        r'other': other
            .map((el) => Serializers.instance
                .serialize<_$sealed_classes.ShapeWithOverriddenCustomJson>(el))
            .toList(),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance
            .deserialize<_$sealed_classes.ShapeWithOverriddenCustomJson>(el))
        .toList();
  }

  Future<_$sealed_classes.ShapeWithOverriddenCustomJson>
      rectangleWithOverriddenCustomJson(
          _$sealed_classes.RectangleWithOverriddenCustomJson rectangle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/rectangle-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'rectangle': Serializers.instance
            .serialize<_$sealed_classes.RectangleWithOverriddenCustomJson>(
                rectangle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.ShapeWithOverriddenCustomJson>(
            $body['response']);
  }

  Future<_$sealed_classes.CircleWithOverriddenCustomJson>
      circleWithOverriddenCustomJson(
          _$sealed_classes.ShapeWithOverriddenCustomJson circle) async {
    final $response = await celest.httpClient.post(
      celest.baseUri
          .resolve('/sealed-classes/circle-with-overridden-custom-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'circle': Serializers.instance
            .serialize<_$sealed_classes.ShapeWithOverriddenCustomJson>(circle)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.CircleWithOverriddenCustomJson>(
            $body['response']);
  }

  Future<List<_$sealed_classes.OkResult<_$sealed_classes.Shape>>>
      okShapeResults(List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/ok-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance
            .deserialize<_$sealed_classes.OkResult<_$sealed_classes.Shape>>(el))
        .toList();
  }

  Future<List<_$sealed_classes.ErrResult<String>>> errShapeResults(
      List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/err-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance
            .deserialize<_$sealed_classes.ErrResult<String>>(el))
        .toList();
  }

  Future<List<_$sealed_classes.Result<_$sealed_classes.Shape, String>>>
      shapeResults(List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<
            _$sealed_classes.Result<_$sealed_classes.Shape, String>>(el))
        .toList();
  }

  Future<List<_$sealed_classes.Result<_$sealed_classes.Shape, String>>>
      aliasedOkShapeResults(List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-ok-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<
            _$sealed_classes.Result<_$sealed_classes.Shape, String>>(el))
        .toList();
  }

  Future<List<_$sealed_classes.Result<_$sealed_classes.Shape, String>>>
      aliasedErrShapeResults(List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-err-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<
            _$sealed_classes.Result<_$sealed_classes.Shape, String>>(el))
        .toList();
  }

  Future<List<_$sealed_classes.Result<_$sealed_classes.Shape, String>>>
      aliasedShapeResults(List<_$sealed_classes.Shape> shapes) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/aliased-shape-results'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shapes': shapes
            .map((el) =>
                Serializers.instance.serialize<_$sealed_classes.Shape>(el))
            .toList()
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) => Serializers.instance.deserialize<
            _$sealed_classes.Result<_$sealed_classes.Shape, String>>(el))
        .toList();
  }

  Future<_$sealed_classes.SwappedResult<_$sealed_classes.Shape, String>>
      swappedResult(
          _$sealed_classes.Result<_$sealed_classes.Shape, String>
              result) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/swapped-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'result': Serializers.instance
            .serialize<_$sealed_classes.Result<_$sealed_classes.Shape, String>>(
                result)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance.deserialize<
        _$sealed_classes
        .SwappedResult<_$sealed_classes.Shape, String>>($body['response']);
  }

  Future<_$sealed_classes.OkResult<T>>
      genericResult<T extends _$sealed_classes.Shape>(T data) async {
    const $T = {
      _$sealed_classes.Shape: r'Shape',
      _$sealed_classes.Circle: r'Circle',
      _$sealed_classes.Rectangle: r'Rectangle',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/generic-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'$T': $T[T]!,
        r'data': Serializers.instance.serialize<T>(data),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.OkResult<T>>($body['response']);
  }

  Future<List<_$sealed_classes.Result<T, E>>> multipleGenericResult<
      T extends _$sealed_classes.Shape, E extends _$exceptions.ShapeException>(
    T data,
    E error,
  ) async {
    const $T = {
      _$sealed_classes.Shape: r'Shape',
      _$sealed_classes.Circle: r'Circle',
      _$sealed_classes.Rectangle: r'Rectangle',
    };
    const $E = {
      _$exceptions.ShapeException: r'ShapeException',
      _$exceptions.BadShapeException: r'BadShapeException',
    };
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/multiple-generic-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'$T': $T[T]!,
        r'$E': $E[E]!,
        r'data': Serializers.instance.serialize<T>(data),
        r'error': Serializers.instance.serialize<E>(error),
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Iterable<Object?>)
        .map((el) =>
            Serializers.instance.deserialize<_$sealed_classes.Result<T, E>>(el))
        .toList();
  }

  Future<_$sealed_classes.OkShapeResult> okShapeResult(
      _$sealed_classes.Shape shape) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/sealed-classes/ok-shape-result'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'shape': Serializers.instance.serialize<_$sealed_classes.Shape>(shape)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$sealed_classes.OkShapeResult>($body['response']);
  }
}

/// Checks that typedefs work as expected.
class CelestFunctionsTypedefs {
  Never _throwError({
    required int $statusCode,
    required Map<String, Object?> $body,
  }) {
    final $error = ($body['error'] as Map<String, Object?>);
    final $code = ($error['code'] as String);
    final $details = ($error['details'] as Map<String, Object?>?);
    switch ($code) {
      case r'BadRequestException':
        throw Serializers.instance.deserialize<BadRequestException>($details);
      case r'UnauthorizedException':
        throw Serializers.instance.deserialize<UnauthorizedException>($details);
      case r'InternalServerError':
        throw Serializers.instance.deserialize<InternalServerError>($details);
      case r'SerializationException':
        throw Serializers.instance
            .deserialize<SerializationException>($details);
      case _:
        switch ($statusCode) {
          case 400:
            throw BadRequestException($code);
          case _:
            throw InternalServerException($code);
        }
    }
  }

  Future<_$typedefs.Portfolio> portfolio(_$typedefs.Portfolio portfolio) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/portfolio'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({
        r'portfolio':
            Serializers.instance.serialize<_$typedefs.Portfolio>(portfolio)
      }),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return Serializers.instance
        .deserialize<_$typedefs.Portfolio>($body['response']);
  }

  Future<Map<String, dynamic>> json(Map<String, dynamic> json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'json': json}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>);
  }

  Future<Map<String, dynamic>?> nullableJson(Map<String, dynamic>? json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/nullable-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'json': json}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?);
  }

  Future<Map<String, dynamic>?> mixedJson(Map<String, dynamic> json) async {
    final $response = await celest.httpClient.post(
      celest.baseUri.resolve('/typedefs/mixed-json'),
      headers: const {'Content-Type': 'application/json; charset=utf-8'},
      body: _$convert.jsonEncode({r'json': json}),
    );
    final $body =
        (_$convert.jsonDecode($response.body) as Map<String, Object?>);
    if ($response.statusCode != 200) {
      _throwError(
        $statusCode: $response.statusCode,
        $body: $body,
      );
    }
    return ($body['response'] as Map<String, Object?>?);
  }
}
